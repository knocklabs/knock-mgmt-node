// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as StepsAPI from './steps';
import { StepPreviewTemplateParams, StepPreviewTemplateResponse, Steps } from './steps';
import { APIPromise } from '../../api-promise';
import { RequestOptions } from '../../internal/request-options';
import { path } from '../../internal/utils/path';

export class Workflows extends APIResource {
  steps: StepsAPI.Steps = new StepsAPI.Steps(this._client);

  /**
   * Retrieve a workflow by its key and namespace, in a given environment.
   */
  retrieve(
    workflowKey: string,
    query: WorkflowRetrieveParams,
    options?: RequestOptions,
  ): APIPromise<WorkflowRetrieveResponse> {
    return this._client.get(path`/v1/workflows/${workflowKey}`, { query, ...options });
  }

  /**
   * Returns a paginated list of workflows available in a given environment. The
   * workflows are returned in alpha sorted order by its key.
   */
  list(query: WorkflowListParams, options?: RequestOptions): APIPromise<WorkflowListResponse> {
    return this._client.get('/v1/workflows', { query, ...options });
  }

  /**
   * Activates (or deactivates) a workflow in a given environment.
   *
   * Note: This immediately enables or disables a workflow in a given environment
   * without needing to go through environment promotion.
   */
  activate(
    workflowKey: string,
    params: WorkflowActivateParams,
    options?: RequestOptions,
  ): APIPromise<WorkflowActivateResponse> {
    const { environment, ...body } = params;
    return this._client.put(path`/v1/workflows/${workflowKey}/activate`, {
      query: { environment },
      body,
      ...options,
    });
  }

  /**
   * Runs the latest version of a committed workflow in a given environment using the
   * params provided.
   */
  run(
    workflowKey: string,
    params: WorkflowRunParams,
    options?: RequestOptions,
  ): APIPromise<WorkflowRunResponse> {
    const { environment, ...body } = params;
    return this._client.put(path`/v1/workflows/${workflowKey}/run`, {
      query: { environment },
      body,
      ...options,
    });
  }

  /**
   * Updates a workflow of a given key, or creates a new one if it does not yet
   * exist.
   *
   * Note: this endpoint only operates on workflows in the `development` environment.
   */
  upsert(
    workflowKey: string,
    params: WorkflowUpsertParams,
    options?: RequestOptions,
  ): APIPromise<WorkflowUpsertResponse> {
    const { environment, commit, commit_message, ...body } = params;
    return this._client.put(path`/v1/workflows/${workflowKey}`, {
      query: { environment, commit, commit_message },
      body,
      ...options,
    });
  }

  /**
   * Validates a workflow payload without persisting it. Some read-only fields will
   * be empty as they are generated by the system when persisted.
   *
   * Note: Validating a workflow is only done in the development environment context.
   */
  validate(
    workflowKey: string,
    params: WorkflowValidateParams,
    options?: RequestOptions,
  ): APIPromise<WorkflowValidateResponse> {
    const { environment, ...body } = params;
    return this._client.put(path`/v1/workflows/${workflowKey}/validate`, {
      query: { environment },
      body,
      ...options,
    });
  }
}

/**
 * A workflow object.
 */
export interface WorkflowRetrieveResponse {
  /**
   * Whether the workflow is active in the current environment. (read-only)
   */
  active: boolean;

  /**
   * A timestamp of when the workflow was created. (read-only)
   */
  created_at: string;

  /**
   * The slug of the environment in which the workflow exists. (read-only)
   */
  environment: string;

  /**
   * The unique key string for the workflow object. Must be at minimum 3 characters
   * and at maximum 255 characters in length. Must be in the format of ^[a-z0-9_-]+$.
   */
  key: string;

  /**
   * A name for the workflow. Must be at maximum 255 characters in length.
   */
  name: string;

  /**
   * The SHA hash of the workflow data. (read-only)
   */
  sha: string;

  /**
   * A list of workflow step objects in the workflow, which may contain any of:
   * channel step, delay step, batch step, fetch step.
   */
  steps: Array<
    | WorkflowRetrieveResponse.WorkflowChannelStep
    | WorkflowRetrieveResponse.WorkflowDelayStep
    | WorkflowRetrieveResponse.WorkflowBatchStep
    | WorkflowRetrieveResponse.WorkflowThrottleStep
    | unknown
    | WorkflowRetrieveResponse.WorkflowTriggerWorkflowStep
  >;

  /**
   * A timestamp of when the workflow was last updated. (read-only)
   */
  updated_at: string;

  /**
   * Whether the workflow and its steps are in a valid state. (read-only)
   */
  valid: boolean;

  /**
   * A list of categories that the workflow belongs to.
   */
  categories?: Array<string>;

  /**
   * A group of conditions to be evaluated
   */
  conditions?:
    | WorkflowRetrieveResponse.ConditionGroupAllMatch
    | WorkflowRetrieveResponse.ConditionGroupAnyMatch
    | null;

  /**
   * A timestamp of when the workflow was deleted. (read-only)
   */
  deleted_at?: string;

  /**
   * An arbitrary string attached to a workflow object. Useful for adding notes about
   * the workflow for internal purposes. Maximum of 280 characters allowed.
   */
  description?: string;

  /**
   * A map of workflow settings.
   */
  settings?: WorkflowRetrieveResponse.Settings;

  /**
   * A JSON schema for the expected structure of the workflow trigger's data payload.
   * Used to validate trigger requests. (optional)
   */
  trigger_data_json_schema?: unknown;

  /**
   * The frequency at which the workflow should be triggered. One of:
   * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
   * to "every_trigger".
   */
  trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
}

export namespace WorkflowRetrieveResponse {
  /**
   * A channel step within a workflow.
   */
  export interface WorkflowChannelStep {
    /**
     * A name for the workflow step.
     */
    name: string;

    /**
     * The reference key of the workflow step. Must be unique per workflow.
     */
    ref: string;

    /**
     * The message template set up with the channel step. The shape of the template
     * depends on the type of the channel you'll be sending to. See below for
     * definitions of each channel type template: email, in-app, SMS, push, chat, and
     * webhook.
     */
    template:
      | WorkflowChannelStep.EmailTemplate
      | WorkflowChannelStep.InAppFeedTemplate
      | WorkflowChannelStep.SMSTemplate
      | WorkflowChannelStep.PushTemplate
      | WorkflowChannelStep.ChatTemplate
      | WorkflowChannelStep.WebhookTemplate;

    /**
     * The type of the workflow step.
     */
    type: 'channel';

    /**
     * The key of the channel group to which the channel step will be sending a
     * notification. A channel step can have either a channel key or a channel group
     * key, but not both.
     */
    channel_group_key?: string | null;

    /**
     * The key of the channel to which the channel step will be sending a notification.
     * A channel step can have either a channel key or a channel group key, but not
     * both.
     */
    channel_key?: string | null;

    /**
     * A map of channel overrides for the channel step.
     */
    channel_overrides?:
      | WorkflowChannelStep.EmailChannelSettings
      | WorkflowChannelStep.InAppFeedChannelSettings
      | WorkflowChannelStep.SMSChannelSettings
      | WorkflowChannelStep.ChatChannelSettings
      | null;

    /**
     * A group of conditions to be evaluated
     */
    conditions?:
      | WorkflowChannelStep.ConditionGroupAllMatch
      | WorkflowChannelStep.ConditionGroupAnyMatch
      | null;

    /**
     * An arbitrary string attached to a workflow step. Useful for adding notes about
     * the workflow for internal purposes.
     */
    description?: string | null;

    /**
     * A list of send window objects. Must include one send window object per day of
     * the week.
     */
    send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
  }

  export namespace WorkflowChannelStep {
    /**
     * An email message template.
     */
    export interface EmailTemplate {
      /**
       * The subject of the email.
       */
      subject: string;

      /**
       * An HTML template for the email body. Either `html_body` or `visual_blocks` must
       * be provided.
       */
      html_body?: string;

      /**
       * The settings for the email template. Can be omitted.
       */
      settings?: EmailTemplate.Settings | null;

      /**
       * A text template for the email body. Only present if opted out from
       * autogenerating it from the HTML template.
       */
      text_body?: string | null;

      /**
       * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
       * provided.
       */
      visual_blocks?: Array<
        | EmailTemplate.ButtonSetBlock
        | EmailTemplate.DividerBlock
        | EmailTemplate.HTMLBlock
        | EmailTemplate.MarkdownBlock
        | EmailTemplate.PartialBlock
      >;
    }

    export namespace EmailTemplate {
      /**
       * The settings for the email template. Can be omitted.
       */
      export interface Settings {
        /**
         * The object path in the data payload (of the workflow trigger call) to resolve
         * attachments.
         */
        attachment_key?: string | null;

        /**
         * The key of the email layout which the step is using.
         */
        layout_key?: string | null;

        /**
         * A liquid template that will be injected into the layout above the message
         * template content.
         */
        pre_content?: string | null;
      }

      /**
       * A button set block in an email template.
       */
      export interface ButtonSetBlock {
        /**
         * The ID of the block.
         */
        id: string;

        buttons: Array<ButtonSetBlock.Button>;

        /**
         * The type of the block.
         */
        type: string;

        /**
         * The version of the block.
         */
        version: number;

        /**
         * The layout attributes of the block.
         */
        layout_attrs?: ButtonSetBlock.LayoutAttrs;
      }

      export namespace ButtonSetBlock {
        /**
         * A button in a button set block.
         */
        export interface Button {
          action: string;

          label: string;

          variant: string;

          size_attrs?: Button.SizeAttrs;

          style_attrs?: Button.StyleAttrs;
        }

        export namespace Button {
          export interface SizeAttrs {
            is_fullwidth?: boolean;

            size?: 'sm' | 'md' | 'lg';
          }

          export interface StyleAttrs {
            background_color?: string;

            border_color?: string;

            border_radius?: number;

            border_width?: number;

            text_color?: string;
          }
        }

        /**
         * The layout attributes of the block.
         */
        export interface LayoutAttrs {
          column_gap: number;

          horizontal_align: 'left' | 'center' | 'right';

          padding_bottom: number;

          padding_left: number;

          padding_right: number;

          padding_top: number;
        }
      }

      /**
       * A divider block in an email template.
       */
      export interface DividerBlock {
        /**
         * The ID of the block.
         */
        id: string;

        /**
         * The type of the block.
         */
        type: string;

        /**
         * The version of the block.
         */
        version: number;

        /**
         * The layout attributes of the block.
         */
        layout_attrs?: DividerBlock.LayoutAttrs;
      }

      export namespace DividerBlock {
        /**
         * The layout attributes of the block.
         */
        export interface LayoutAttrs {
          padding_bottom: number;

          padding_left: number;

          padding_right: number;

          padding_top: number;
        }
      }

      /**
       * An HTML block in an email template.
       */
      export interface HTMLBlock {
        /**
         * The ID of the block.
         */
        id: string;

        /**
         * The HTML content of the block.
         */
        content: string;

        /**
         * The type of the block.
         */
        type: string;

        /**
         * The version of the block.
         */
        version: number;
      }

      /**
       * A markdown block in an email template.
       */
      export interface MarkdownBlock {
        /**
         * The ID of the block.
         */
        id: string;

        /**
         * The markdown content of the block.
         */
        content: string;

        /**
         * The type of the block.
         */
        type: string;

        /**
         * The flavor of markdown to use for the block.
         */
        variant: string;

        /**
         * The version of the block.
         */
        version: number;

        /**
         * The layout attributes of the block.
         */
        layout_attrs?: MarkdownBlock.LayoutAttrs;
      }

      export namespace MarkdownBlock {
        /**
         * The layout attributes of the block.
         */
        export interface LayoutAttrs {
          padding_bottom: number;

          padding_left: number;

          padding_right: number;

          padding_top: number;
        }
      }

      /**
       * A partial block in an email template, used to render a reusable partial
       * component.
       */
      export interface PartialBlock {
        /**
         * The ID of the block.
         */
        id: string;

        /**
         * The attributes to pass to the partial block.
         */
        attrs: Record<string, unknown>;

        /**
         * The key of the partial block to invoke.
         */
        key: string;

        /**
         * The name of the partial block.
         */
        name: string;

        /**
         * The type of the block.
         */
        type: string;

        /**
         * The version of the block.
         */
        version: number;

        /**
         * The layout attributes of the block.
         */
        layout_attrs?: PartialBlock.LayoutAttrs;
      }

      export namespace PartialBlock {
        /**
         * The layout attributes of the block.
         */
        export interface LayoutAttrs {
          padding_bottom: number;

          padding_left: number;

          padding_right: number;

          padding_top: number;
        }
      }
    }

    /**
     * An in-app feed template.
     */
    export interface InAppFeedTemplate {
      /**
       * The markdown body of the in-app feed.
       */
      markdown_body: string;

      /**
       * The action buttons of the in-app feed.
       */
      action_buttons?: Array<InAppFeedTemplate.ActionButton>;

      /**
       * The URL to navigate to when the in-app feed is tapped. Can be omitted for
       * multi-action templates, where the action buttons will be used instead.
       */
      action_url?: string | null;
    }

    export namespace InAppFeedTemplate {
      /**
       * A single-action button to be rendered in an in-app feed cell.
       */
      export interface ActionButton {
        /**
         * The action of the action button.
         */
        action: string;

        /**
         * The label of the action button.
         */
        label: string;
      }
    }

    /**
     * An SMS template.
     */
    export interface SMSTemplate {
      /**
       * The message of the SMS.
       */
      text_body: string;

      /**
       * The settings for the SMS template.
       */
      settings?: SMSTemplate.Settings | null;
    }

    export namespace SMSTemplate {
      /**
       * The settings for the SMS template.
       */
      export interface Settings {
        /**
         * A JSON object overrides the payload sent to the SMS provider.
         */
        payload_overrides?: string | null;

        /**
         * An override for the phone number to send the SMS to. When not set, defaults to
         * `recipient.phone_number`.
         */
        to_number?: string | null;
      }
    }

    /**
     * A push notification template.
     */
    export interface PushTemplate {
      /**
       * The body of the push notification.
       */
      text_body: string;

      /**
       * The title of the push notification.
       */
      title: string;

      /**
       * The settings for the push template. Can be omitted.
       */
      settings?: PushTemplate.Settings | null;
    }

    export namespace PushTemplate {
      /**
       * The settings for the push template. Can be omitted.
       */
      export interface Settings {
        /**
         * The delivery type of the push notification. Defaults to `content`. Set as silent
         * to send a data-only notification. When set to `data`, no body will be sent.
         */
        delivery_type?: 'silent' | 'content';

        /**
         * A JSON object overrides the payload sent to the push provider.
         */
        payload_overrides?: string;
      }
    }

    /**
     * A chat template.
     */
    export interface ChatTemplate {
      /**
       * The markdown body of the chat template.
       */
      markdown_body: string;

      /**
       * A JSON template for the chat notification message payload. Only present if not
       * using the markdown body.
       */
      json_body?: string | null;

      /**
       * The summary of the chat template.
       */
      summary?: string;
    }

    /**
     * A webhook template. By default, a webhook step will use the request settings you
     * configured in your webhook channel. You can override this as you see fit on a
     * per-step basis.
     */
    export interface WebhookTemplate {
      /**
       * The HTTP method of the webhook.
       */
      method: 'get' | 'post' | 'put' | 'delete' | 'patch';

      /**
       * The URL of the webhook.
       */
      url: string;

      /**
       * A body of the request. Only used for POST or PUT requests.
       */
      body?: string | null;

      /**
       * A list of key-value pairs for the request headers. Each object should contain
       * key and value fields with string values.
       */
      headers?: Array<WebhookTemplate.Header>;

      /**
       * A list of key-value pairs for the request query params. Each object should
       * contain key and value fields with string values.
       */
      query_params?: Array<WebhookTemplate.QueryParam>;
    }

    export namespace WebhookTemplate {
      export interface Header {
        /**
         * The key of the header.
         */
        key: string;

        /**
         * The value of the header.
         */
        value: string;
      }

      export interface QueryParam {
        /**
         * The key of the query param.
         */
        key: string;

        /**
         * The value of the query param.
         */
        value: string;
      }
    }

    /**
     * Email channel settings
     */
    export interface EmailChannelSettings {
      /**
       * The BCC address on email notifications. Supports liquid. Defaults to
       * `from_address`.
       */
      bcc_address?: string | null;

      /**
       * The CC address on email notifications. Supports liquid. Defaults to
       * `from_address`.
       */
      cc_address?: string | null;

      /**
       * The email address from which this channel will send. Supports liquid.
       */
      from_email?: string | null;

      /**
       * The name from which this channel will send. Supports liquid
       */
      from_name?: string | null;

      /**
       * A JSON template for any custom overrides to merge into the API payload that is
       * sent to the email provider. Supports liquid.
       */
      json_overrides?: string | null;

      /**
       * Whether to track link clicks on email notifications.
       */
      link_tracking?: boolean;

      /**
       * Whether to track opens on email notifications.
       */
      open_tracking?: boolean;

      /**
       * The Reply-to address on email notifications. Supports liquid. Defaults to
       * `from_address`.
       */
      reply_to_address?: string | null;

      /**
       * The email address to which this channel will send. Defaults to
       * `recipient.email`. Supports liquid.
       */
      to_address?: string;
    }

    /**
     * In-app feed channel settings
     */
    export interface InAppFeedChannelSettings {
      /**
       * Whether to track link clicks on in-app feed notifications.
       */
      link_tracking?: boolean;
    }

    /**
     * SMS channel settings
     */
    export interface SMSChannelSettings {
      /**
       * Whether to track link clicks on SMS notifications.
       */
      link_tracking?: boolean;
    }

    /**
     * Chat channel settings
     */
    export interface ChatChannelSettings {
      /**
       * Whether to resolve chat provider user IDs using a Knock user's email address.
       * Only relevant for Slack channels for the time being.
       */
      email_based_user_id_resolution?: boolean;

      /**
       * Whether to track link clicks on chat notifications.
       */
      link_tracking?: boolean;
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A send window time for a notification. Describes a single day.
     */
    export interface SendWindow {
      day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

      type: 'send' | 'do_not_send';

      from?: string | null;

      until?: string | null;
    }
  }

  /**
   * A delay step within a workflow.
   */
  export interface WorkflowDelayStep {
    /**
     * A group of conditions to be evaluated
     */
    conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

    /**
     * An arbitrary string attached to a workflow step. Useful for adding notes about
     * the workflow for internal purposes.
     */
    description: string | null;

    /**
     * A name for the workflow step.
     */
    name: string;

    /**
     * The reference key of the workflow step. Must be unique per workflow.
     */
    ref: string;

    /**
     * The settings for the delay step. Both fields can be set to compute a delay where
     * `delay_for` is an offset from the `delay_until_field_path`.
     */
    settings: WorkflowDelayStep.Settings;

    /**
     * The type of the workflow step.
     */
    type: 'delay';
  }

  export namespace WorkflowDelayStep {
    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * The settings for the delay step. Both fields can be set to compute a delay where
     * `delay_for` is an offset from the `delay_until_field_path`.
     */
    export interface Settings {
      /**
       * A duration of time, represented as a unit and a value.
       */
      delay_for?: Settings.DelayFor | null;

      /**
       * When set will use the path to resolve the delay into a timestamp from the
       * property referenced
       */
      delay_until_field_path?: string;
    }

    export namespace Settings {
      /**
       * A duration of time, represented as a unit and a value.
       */
      export interface DelayFor {
        unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

        value: number;
      }
    }
  }

  /**
   * A workflow batch step
   */
  export interface WorkflowBatchStep {
    /**
     * An arbitrary string attached to a workflow step. Useful for adding notes about
     * the workflow for internal purposes.
     */
    description: string | null;

    /**
     * A name for the workflow step.
     */
    name: string;

    /**
     * The reference key of the workflow step. Must be unique per workflow.
     */
    ref: string;

    /**
     * The settings for the batch step.
     */
    settings: WorkflowBatchStep.Settings;

    /**
     * The type of the workflow step.
     */
    type: 'batch';
  }

  export namespace WorkflowBatchStep {
    /**
     * The settings for the batch step.
     */
    export interface Settings {
      /**
       * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
       * When set to “flush_leading”, the first item in the batch will be executed
       * immediately, and the rest will be batched.
       */
      batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

      /**
       * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
       */
      batch_items_max_limit?: number | null;

      /**
       * The maximum number of batch items allowed to be rendered into a template.
       * Between: 1 and 100. Defaults to 10.
       */
      batch_items_render_limit?: number | null;

      /**
       * The data property to use to batch notifications per recipient.
       */
      batch_key?: string | null;

      /**
       * The order describing whether to return the first or last ten batch items in the
       * activities variable. One of: “asc” or “desc”.
       */
      batch_order?: 'asc' | 'desc' | null;

      /**
       * The data path to resolve the batch window. The resolved value must be an
       * ISO-8601 timestamp.
       */
      batch_until_field_path?: string | null;

      /**
       * A duration of time, represented as a unit and a value.
       */
      batch_window?: Settings.BatchWindow | null;

      /**
       * A duration of time, represented as a unit and a value.
       */
      batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

      /**
       * The type of the batch window used. One of: “fixed” or “sliding”.
       */
      batch_window_type?: 'fixed' | 'sliding' | null;
    }

    export namespace Settings {
      /**
       * A duration of time, represented as a unit and a value.
       */
      export interface BatchWindow {
        unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

        value: number;
      }

      /**
       * A duration of time, represented as a unit and a value.
       */
      export interface BatchWindowExtensionLimit {
        unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

        value: number;
      }
    }
  }

  /**
   * A workflow throttle step
   */
  export interface WorkflowThrottleStep {
    /**
     * A name for the workflow step.
     */
    name: string;

    /**
     * The reference key of the workflow step. Must be unique per workflow.
     */
    ref: string;

    /**
     * The settings for the throttle step.
     */
    settings: WorkflowThrottleStep.Settings;

    /**
     * The type of the workflow step.
     */
    type: 'throttle';

    /**
     * A group of conditions to be evaluated
     */
    conditions?:
      | WorkflowThrottleStep.ConditionGroupAllMatch
      | WorkflowThrottleStep.ConditionGroupAnyMatch
      | null;

    /**
     * An arbitrary string attached to a workflow step. Useful for adding notes about
     * the workflow for internal purposes.
     */
    description?: string | null;
  }

  export namespace WorkflowThrottleStep {
    /**
     * The settings for the throttle step.
     */
    export interface Settings {
      /**
       * The data property to use to throttle notifications per recipient.
       */
      throttle_key?: string | null;

      /**
       * The maximum number of workflows to allow within the duration window. Defaults
       * to 1.
       */
      throttle_limit?: number | null;

      /**
       * A duration of time, represented as a unit and a value.
       */
      throttle_window?: Settings.ThrottleWindow | null;

      /**
       * The data path to resolve the throttle window. The resolved value must be an
       * ISO-8601 timestamp.
       */
      throttle_window_field_path?: string | null;
    }

    export namespace Settings {
      /**
       * A duration of time, represented as a unit and a value.
       */
      export interface ThrottleWindow {
        unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

        value: number;
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }
  }

  /**
   * A workflow trigger workflow step.
   */
  export interface WorkflowTriggerWorkflowStep {
    /**
     * A name for the workflow step.
     */
    name: string;

    /**
     * The reference key of the workflow step. Must be unique per workflow.
     */
    ref: string;

    /**
     * The settings for the workflow trigger workflow step.
     */
    settings: WorkflowTriggerWorkflowStep.Settings;

    /**
     * The type of the workflow step.
     */
    type: 'trigger_workflow';

    /**
     * A group of conditions to be evaluated
     */
    conditions?:
      | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
      | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
      | null;

    /**
     * A description for the workflow step.
     */
    description?: string;
  }

  export namespace WorkflowTriggerWorkflowStep {
    /**
     * The settings for the workflow trigger workflow step.
     */
    export interface Settings {
      /**
       * The actor to trigger the workflow with. Supports liquid.
       */
      actor?: string;

      /**
       * The cancellation key to trigger the workflow with. Supports liquid.
       */
      cancellation_key?: string;

      /**
       * The data to be supplied to the workflow. Supports liquid.
       */
      data?: string;

      recipients?: unknown;

      /**
       * The tenant to trigger the workflow with. Supports liquid.
       */
      tenant?: string;

      /**
       * The key of the workflow to trigger. Supports liquid.
       */
      workflow_key?: string;
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }
  }

  /**
   * A group of conditions that must all be met.
   */
  export interface ConditionGroupAllMatch {
    all: Array<ConditionGroupAllMatch.All>;
  }

  export namespace ConditionGroupAllMatch {
    /**
     * A condition to be evaluated
     */
    export interface All {
      /**
       * The operator to use in the evaluation of the condition.
       */
      operator:
        | 'equal_to'
        | 'not_equal_to'
        | 'greater_than'
        | 'less_than'
        | 'greater_than_or_equal_to'
        | 'less_than_or_equal_to'
        | 'contains'
        | 'not_contains'
        | 'contains_all'
        | 'empty'
        | 'not_empty'
        | 'is_audience_member'
        | 'is_not_audience_member';

      /**
       * The variable to be evaluated. Variables can be either static values or dynamic
       * properties. Static values will always be JSON decoded so will support strings,
       * lists, objects, numbers, and booleans. Dynamic values should be path
       * expressions.
       */
      variable: string;

      /**
       * The argument to be evaluated. Arguments can be either static values or dynamic
       * properties. Static values will always be JSON decoded so will support strings,
       * lists, objects, numbers, and booleans. Dynamic values should be path
       * expressions.
       */
      argument?: string | null;
    }
  }

  /**
   * A group of conditions that any must be met. Can contain nested alls.
   */
  export interface ConditionGroupAnyMatch {
    any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
  }

  export namespace ConditionGroupAnyMatch {
    /**
     * A condition to be evaluated
     */
    export interface Condition {
      /**
       * The operator to use in the evaluation of the condition.
       */
      operator:
        | 'equal_to'
        | 'not_equal_to'
        | 'greater_than'
        | 'less_than'
        | 'greater_than_or_equal_to'
        | 'less_than_or_equal_to'
        | 'contains'
        | 'not_contains'
        | 'contains_all'
        | 'empty'
        | 'not_empty'
        | 'is_audience_member'
        | 'is_not_audience_member';

      /**
       * The variable to be evaluated. Variables can be either static values or dynamic
       * properties. Static values will always be JSON decoded so will support strings,
       * lists, objects, numbers, and booleans. Dynamic values should be path
       * expressions.
       */
      variable: string;

      /**
       * The argument to be evaluated. Arguments can be either static values or dynamic
       * properties. Static values will always be JSON decoded so will support strings,
       * lists, objects, numbers, and booleans. Dynamic values should be path
       * expressions.
       */
      argument?: string | null;
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }
  }

  /**
   * A map of workflow settings.
   */
  export interface Settings {
    /**
     * Whether the workflow is commercial. Defaults to false.
     */
    is_commercial?: boolean;

    /**
     * Whether to ignore recipient preferences for a given type of notification. If
     * true, will send for every channel in the workflow even if the recipient has
     * opted out of a certain kind. Defaults to false.
     */
    override_preferences?: boolean;
  }
}

/**
 * A paginated list of Workflow. Contains a list of entries and page information.
 */
export interface WorkflowListResponse {
  entries: Array<WorkflowListResponse.Entry>;

  /**
   * The information about a paginated result
   */
  page_info: WorkflowListResponse.PageInfo;
}

export namespace WorkflowListResponse {
  /**
   * A workflow object.
   */
  export interface Entry {
    /**
     * Whether the workflow is active in the current environment. (read-only)
     */
    active: boolean;

    /**
     * A timestamp of when the workflow was created. (read-only)
     */
    created_at: string;

    /**
     * The slug of the environment in which the workflow exists. (read-only)
     */
    environment: string;

    /**
     * The unique key string for the workflow object. Must be at minimum 3 characters
     * and at maximum 255 characters in length. Must be in the format of ^[a-z0-9_-]+$.
     */
    key: string;

    /**
     * A name for the workflow. Must be at maximum 255 characters in length.
     */
    name: string;

    /**
     * The SHA hash of the workflow data. (read-only)
     */
    sha: string;

    /**
     * A list of workflow step objects in the workflow, which may contain any of:
     * channel step, delay step, batch step, fetch step.
     */
    steps: Array<
      | Entry.WorkflowChannelStep
      | Entry.WorkflowDelayStep
      | Entry.WorkflowBatchStep
      | Entry.WorkflowThrottleStep
      | unknown
      | Entry.WorkflowTriggerWorkflowStep
    >;

    /**
     * A timestamp of when the workflow was last updated. (read-only)
     */
    updated_at: string;

    /**
     * Whether the workflow and its steps are in a valid state. (read-only)
     */
    valid: boolean;

    /**
     * A list of categories that the workflow belongs to.
     */
    categories?: Array<string>;

    /**
     * A group of conditions to be evaluated
     */
    conditions?: Entry.ConditionGroupAllMatch | Entry.ConditionGroupAnyMatch | null;

    /**
     * A timestamp of when the workflow was deleted. (read-only)
     */
    deleted_at?: string;

    /**
     * An arbitrary string attached to a workflow object. Useful for adding notes about
     * the workflow for internal purposes. Maximum of 280 characters allowed.
     */
    description?: string;

    /**
     * A map of workflow settings.
     */
    settings?: Entry.Settings;

    /**
     * A JSON schema for the expected structure of the workflow trigger's data payload.
     * Used to validate trigger requests. (optional)
     */
    trigger_data_json_schema?: unknown;

    /**
     * The frequency at which the workflow should be triggered. One of:
     * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
     * to "every_trigger".
     */
    trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
  }

  export namespace Entry {
    /**
     * A channel step within a workflow.
     */
    export interface WorkflowChannelStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The message template set up with the channel step. The shape of the template
       * depends on the type of the channel you'll be sending to. See below for
       * definitions of each channel type template: email, in-app, SMS, push, chat, and
       * webhook.
       */
      template:
        | WorkflowChannelStep.EmailTemplate
        | WorkflowChannelStep.InAppFeedTemplate
        | WorkflowChannelStep.SMSTemplate
        | WorkflowChannelStep.PushTemplate
        | WorkflowChannelStep.ChatTemplate
        | WorkflowChannelStep.WebhookTemplate;

      /**
       * The type of the workflow step.
       */
      type: 'channel';

      /**
       * The key of the channel group to which the channel step will be sending a
       * notification. A channel step can have either a channel key or a channel group
       * key, but not both.
       */
      channel_group_key?: string | null;

      /**
       * The key of the channel to which the channel step will be sending a notification.
       * A channel step can have either a channel key or a channel group key, but not
       * both.
       */
      channel_key?: string | null;

      /**
       * A map of channel overrides for the channel step.
       */
      channel_overrides?:
        | WorkflowChannelStep.EmailChannelSettings
        | WorkflowChannelStep.InAppFeedChannelSettings
        | WorkflowChannelStep.SMSChannelSettings
        | WorkflowChannelStep.ChatChannelSettings
        | null;

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowChannelStep.ConditionGroupAllMatch
        | WorkflowChannelStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;

      /**
       * A list of send window objects. Must include one send window object per day of
       * the week.
       */
      send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
    }

    export namespace WorkflowChannelStep {
      /**
       * An email message template.
       */
      export interface EmailTemplate {
        /**
         * The subject of the email.
         */
        subject: string;

        /**
         * An HTML template for the email body. Either `html_body` or `visual_blocks` must
         * be provided.
         */
        html_body?: string;

        /**
         * The settings for the email template. Can be omitted.
         */
        settings?: EmailTemplate.Settings | null;

        /**
         * A text template for the email body. Only present if opted out from
         * autogenerating it from the HTML template.
         */
        text_body?: string | null;

        /**
         * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
         * provided.
         */
        visual_blocks?: Array<
          | EmailTemplate.ButtonSetBlock
          | EmailTemplate.DividerBlock
          | EmailTemplate.HTMLBlock
          | EmailTemplate.MarkdownBlock
          | EmailTemplate.PartialBlock
        >;
      }

      export namespace EmailTemplate {
        /**
         * The settings for the email template. Can be omitted.
         */
        export interface Settings {
          /**
           * The object path in the data payload (of the workflow trigger call) to resolve
           * attachments.
           */
          attachment_key?: string | null;

          /**
           * The key of the email layout which the step is using.
           */
          layout_key?: string | null;

          /**
           * A liquid template that will be injected into the layout above the message
           * template content.
           */
          pre_content?: string | null;
        }

        /**
         * A button set block in an email template.
         */
        export interface ButtonSetBlock {
          /**
           * The ID of the block.
           */
          id: string;

          buttons: Array<ButtonSetBlock.Button>;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: ButtonSetBlock.LayoutAttrs;
        }

        export namespace ButtonSetBlock {
          /**
           * A button in a button set block.
           */
          export interface Button {
            action: string;

            label: string;

            variant: string;

            size_attrs?: Button.SizeAttrs;

            style_attrs?: Button.StyleAttrs;
          }

          export namespace Button {
            export interface SizeAttrs {
              is_fullwidth?: boolean;

              size?: 'sm' | 'md' | 'lg';
            }

            export interface StyleAttrs {
              background_color?: string;

              border_color?: string;

              border_radius?: number;

              border_width?: number;

              text_color?: string;
            }
          }

          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            column_gap: number;

            horizontal_align: 'left' | 'center' | 'right';

            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A divider block in an email template.
         */
        export interface DividerBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: DividerBlock.LayoutAttrs;
        }

        export namespace DividerBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * An HTML block in an email template.
         */
        export interface HTMLBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The HTML content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;
        }

        /**
         * A markdown block in an email template.
         */
        export interface MarkdownBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The markdown content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The flavor of markdown to use for the block.
           */
          variant: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: MarkdownBlock.LayoutAttrs;
        }

        export namespace MarkdownBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A partial block in an email template, used to render a reusable partial
         * component.
         */
        export interface PartialBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The attributes to pass to the partial block.
           */
          attrs: Record<string, unknown>;

          /**
           * The key of the partial block to invoke.
           */
          key: string;

          /**
           * The name of the partial block.
           */
          name: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: PartialBlock.LayoutAttrs;
        }

        export namespace PartialBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }
      }

      /**
       * An in-app feed template.
       */
      export interface InAppFeedTemplate {
        /**
         * The markdown body of the in-app feed.
         */
        markdown_body: string;

        /**
         * The action buttons of the in-app feed.
         */
        action_buttons?: Array<InAppFeedTemplate.ActionButton>;

        /**
         * The URL to navigate to when the in-app feed is tapped. Can be omitted for
         * multi-action templates, where the action buttons will be used instead.
         */
        action_url?: string | null;
      }

      export namespace InAppFeedTemplate {
        /**
         * A single-action button to be rendered in an in-app feed cell.
         */
        export interface ActionButton {
          /**
           * The action of the action button.
           */
          action: string;

          /**
           * The label of the action button.
           */
          label: string;
        }
      }

      /**
       * An SMS template.
       */
      export interface SMSTemplate {
        /**
         * The message of the SMS.
         */
        text_body: string;

        /**
         * The settings for the SMS template.
         */
        settings?: SMSTemplate.Settings | null;
      }

      export namespace SMSTemplate {
        /**
         * The settings for the SMS template.
         */
        export interface Settings {
          /**
           * A JSON object overrides the payload sent to the SMS provider.
           */
          payload_overrides?: string | null;

          /**
           * An override for the phone number to send the SMS to. When not set, defaults to
           * `recipient.phone_number`.
           */
          to_number?: string | null;
        }
      }

      /**
       * A push notification template.
       */
      export interface PushTemplate {
        /**
         * The body of the push notification.
         */
        text_body: string;

        /**
         * The title of the push notification.
         */
        title: string;

        /**
         * The settings for the push template. Can be omitted.
         */
        settings?: PushTemplate.Settings | null;
      }

      export namespace PushTemplate {
        /**
         * The settings for the push template. Can be omitted.
         */
        export interface Settings {
          /**
           * The delivery type of the push notification. Defaults to `content`. Set as silent
           * to send a data-only notification. When set to `data`, no body will be sent.
           */
          delivery_type?: 'silent' | 'content';

          /**
           * A JSON object overrides the payload sent to the push provider.
           */
          payload_overrides?: string;
        }
      }

      /**
       * A chat template.
       */
      export interface ChatTemplate {
        /**
         * The markdown body of the chat template.
         */
        markdown_body: string;

        /**
         * A JSON template for the chat notification message payload. Only present if not
         * using the markdown body.
         */
        json_body?: string | null;

        /**
         * The summary of the chat template.
         */
        summary?: string;
      }

      /**
       * A webhook template. By default, a webhook step will use the request settings you
       * configured in your webhook channel. You can override this as you see fit on a
       * per-step basis.
       */
      export interface WebhookTemplate {
        /**
         * The HTTP method of the webhook.
         */
        method: 'get' | 'post' | 'put' | 'delete' | 'patch';

        /**
         * The URL of the webhook.
         */
        url: string;

        /**
         * A body of the request. Only used for POST or PUT requests.
         */
        body?: string | null;

        /**
         * A list of key-value pairs for the request headers. Each object should contain
         * key and value fields with string values.
         */
        headers?: Array<WebhookTemplate.Header>;

        /**
         * A list of key-value pairs for the request query params. Each object should
         * contain key and value fields with string values.
         */
        query_params?: Array<WebhookTemplate.QueryParam>;
      }

      export namespace WebhookTemplate {
        export interface Header {
          /**
           * The key of the header.
           */
          key: string;

          /**
           * The value of the header.
           */
          value: string;
        }

        export interface QueryParam {
          /**
           * The key of the query param.
           */
          key: string;

          /**
           * The value of the query param.
           */
          value: string;
        }
      }

      /**
       * Email channel settings
       */
      export interface EmailChannelSettings {
        /**
         * The BCC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        bcc_address?: string | null;

        /**
         * The CC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        cc_address?: string | null;

        /**
         * The email address from which this channel will send. Supports liquid.
         */
        from_email?: string | null;

        /**
         * The name from which this channel will send. Supports liquid
         */
        from_name?: string | null;

        /**
         * A JSON template for any custom overrides to merge into the API payload that is
         * sent to the email provider. Supports liquid.
         */
        json_overrides?: string | null;

        /**
         * Whether to track link clicks on email notifications.
         */
        link_tracking?: boolean;

        /**
         * Whether to track opens on email notifications.
         */
        open_tracking?: boolean;

        /**
         * The Reply-to address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        reply_to_address?: string | null;

        /**
         * The email address to which this channel will send. Defaults to
         * `recipient.email`. Supports liquid.
         */
        to_address?: string;
      }

      /**
       * In-app feed channel settings
       */
      export interface InAppFeedChannelSettings {
        /**
         * Whether to track link clicks on in-app feed notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * SMS channel settings
       */
      export interface SMSChannelSettings {
        /**
         * Whether to track link clicks on SMS notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * Chat channel settings
       */
      export interface ChatChannelSettings {
        /**
         * Whether to resolve chat provider user IDs using a Knock user's email address.
         * Only relevant for Slack channels for the time being.
         */
        email_based_user_id_resolution?: boolean;

        /**
         * Whether to track link clicks on chat notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * A send window time for a notification. Describes a single day.
       */
      export interface SendWindow {
        day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

        type: 'send' | 'do_not_send';

        from?: string | null;

        until?: string | null;
      }
    }

    /**
     * A delay step within a workflow.
     */
    export interface WorkflowDelayStep {
      /**
       * A group of conditions to be evaluated
       */
      conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      settings: WorkflowDelayStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'delay';
    }

    export namespace WorkflowDelayStep {
      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      export interface Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        delay_for?: Settings.DelayFor | null;

        /**
         * When set will use the path to resolve the delay into a timestamp from the
         * property referenced
         */
        delay_until_field_path?: string;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface DelayFor {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow batch step
     */
    export interface WorkflowBatchStep {
      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the batch step.
       */
      settings: WorkflowBatchStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'batch';
    }

    export namespace WorkflowBatchStep {
      /**
       * The settings for the batch step.
       */
      export interface Settings {
        /**
         * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
         * When set to “flush_leading”, the first item in the batch will be executed
         * immediately, and the rest will be batched.
         */
        batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

        /**
         * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
         */
        batch_items_max_limit?: number | null;

        /**
         * The maximum number of batch items allowed to be rendered into a template.
         * Between: 1 and 100. Defaults to 10.
         */
        batch_items_render_limit?: number | null;

        /**
         * The data property to use to batch notifications per recipient.
         */
        batch_key?: string | null;

        /**
         * The order describing whether to return the first or last ten batch items in the
         * activities variable. One of: “asc” or “desc”.
         */
        batch_order?: 'asc' | 'desc' | null;

        /**
         * The data path to resolve the batch window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        batch_until_field_path?: string | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window?: Settings.BatchWindow | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

        /**
         * The type of the batch window used. One of: “fixed” or “sliding”.
         */
        batch_window_type?: 'fixed' | 'sliding' | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }

        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindowExtensionLimit {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow throttle step
     */
    export interface WorkflowThrottleStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the throttle step.
       */
      settings: WorkflowThrottleStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'throttle';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowThrottleStep.ConditionGroupAllMatch
        | WorkflowThrottleStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;
    }

    export namespace WorkflowThrottleStep {
      /**
       * The settings for the throttle step.
       */
      export interface Settings {
        /**
         * The data property to use to throttle notifications per recipient.
         */
        throttle_key?: string | null;

        /**
         * The maximum number of workflows to allow within the duration window. Defaults
         * to 1.
         */
        throttle_limit?: number | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        throttle_window?: Settings.ThrottleWindow | null;

        /**
         * The data path to resolve the throttle window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        throttle_window_field_path?: string | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface ThrottleWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A workflow trigger workflow step.
     */
    export interface WorkflowTriggerWorkflowStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the workflow trigger workflow step.
       */
      settings: WorkflowTriggerWorkflowStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'trigger_workflow';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
        | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
        | null;

      /**
       * A description for the workflow step.
       */
      description?: string;
    }

    export namespace WorkflowTriggerWorkflowStep {
      /**
       * The settings for the workflow trigger workflow step.
       */
      export interface Settings {
        /**
         * The actor to trigger the workflow with. Supports liquid.
         */
        actor?: string;

        /**
         * The cancellation key to trigger the workflow with. Supports liquid.
         */
        cancellation_key?: string;

        /**
         * The data to be supplied to the workflow. Supports liquid.
         */
        data?: string;

        recipients?: unknown;

        /**
         * The tenant to trigger the workflow with. Supports liquid.
         */
        tenant?: string;

        /**
         * The key of the workflow to trigger. Supports liquid.
         */
        workflow_key?: string;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A map of workflow settings.
     */
    export interface Settings {
      /**
       * Whether the workflow is commercial. Defaults to false.
       */
      is_commercial?: boolean;

      /**
       * Whether to ignore recipient preferences for a given type of notification. If
       * true, will send for every channel in the workflow even if the recipient has
       * opted out of a certain kind. Defaults to false.
       */
      override_preferences?: boolean;
    }
  }

  /**
   * The information about a paginated result
   */
  export interface PageInfo {
    __typename: string;

    page_size: number;

    after?: string | null;

    before?: string | null;
  }
}

/**
 * Wraps the Workflow response under the workflow key.
 */
export interface WorkflowActivateResponse {
  /**
   * A workflow object.
   */
  workflow: WorkflowActivateResponse.Workflow;
}

export namespace WorkflowActivateResponse {
  /**
   * A workflow object.
   */
  export interface Workflow {
    /**
     * Whether the workflow is active in the current environment. (read-only)
     */
    active: boolean;

    /**
     * A timestamp of when the workflow was created. (read-only)
     */
    created_at: string;

    /**
     * The slug of the environment in which the workflow exists. (read-only)
     */
    environment: string;

    /**
     * The unique key string for the workflow object. Must be at minimum 3 characters
     * and at maximum 255 characters in length. Must be in the format of ^[a-z0-9_-]+$.
     */
    key: string;

    /**
     * A name for the workflow. Must be at maximum 255 characters in length.
     */
    name: string;

    /**
     * The SHA hash of the workflow data. (read-only)
     */
    sha: string;

    /**
     * A list of workflow step objects in the workflow, which may contain any of:
     * channel step, delay step, batch step, fetch step.
     */
    steps: Array<
      | Workflow.WorkflowChannelStep
      | Workflow.WorkflowDelayStep
      | Workflow.WorkflowBatchStep
      | Workflow.WorkflowThrottleStep
      | unknown
      | Workflow.WorkflowTriggerWorkflowStep
    >;

    /**
     * A timestamp of when the workflow was last updated. (read-only)
     */
    updated_at: string;

    /**
     * Whether the workflow and its steps are in a valid state. (read-only)
     */
    valid: boolean;

    /**
     * A list of categories that the workflow belongs to.
     */
    categories?: Array<string>;

    /**
     * A group of conditions to be evaluated
     */
    conditions?: Workflow.ConditionGroupAllMatch | Workflow.ConditionGroupAnyMatch | null;

    /**
     * A timestamp of when the workflow was deleted. (read-only)
     */
    deleted_at?: string;

    /**
     * An arbitrary string attached to a workflow object. Useful for adding notes about
     * the workflow for internal purposes. Maximum of 280 characters allowed.
     */
    description?: string;

    /**
     * A map of workflow settings.
     */
    settings?: Workflow.Settings;

    /**
     * A JSON schema for the expected structure of the workflow trigger's data payload.
     * Used to validate trigger requests. (optional)
     */
    trigger_data_json_schema?: unknown;

    /**
     * The frequency at which the workflow should be triggered. One of:
     * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
     * to "every_trigger".
     */
    trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
  }

  export namespace Workflow {
    /**
     * A channel step within a workflow.
     */
    export interface WorkflowChannelStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The message template set up with the channel step. The shape of the template
       * depends on the type of the channel you'll be sending to. See below for
       * definitions of each channel type template: email, in-app, SMS, push, chat, and
       * webhook.
       */
      template:
        | WorkflowChannelStep.EmailTemplate
        | WorkflowChannelStep.InAppFeedTemplate
        | WorkflowChannelStep.SMSTemplate
        | WorkflowChannelStep.PushTemplate
        | WorkflowChannelStep.ChatTemplate
        | WorkflowChannelStep.WebhookTemplate;

      /**
       * The type of the workflow step.
       */
      type: 'channel';

      /**
       * The key of the channel group to which the channel step will be sending a
       * notification. A channel step can have either a channel key or a channel group
       * key, but not both.
       */
      channel_group_key?: string | null;

      /**
       * The key of the channel to which the channel step will be sending a notification.
       * A channel step can have either a channel key or a channel group key, but not
       * both.
       */
      channel_key?: string | null;

      /**
       * A map of channel overrides for the channel step.
       */
      channel_overrides?:
        | WorkflowChannelStep.EmailChannelSettings
        | WorkflowChannelStep.InAppFeedChannelSettings
        | WorkflowChannelStep.SMSChannelSettings
        | WorkflowChannelStep.ChatChannelSettings
        | null;

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowChannelStep.ConditionGroupAllMatch
        | WorkflowChannelStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;

      /**
       * A list of send window objects. Must include one send window object per day of
       * the week.
       */
      send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
    }

    export namespace WorkflowChannelStep {
      /**
       * An email message template.
       */
      export interface EmailTemplate {
        /**
         * The subject of the email.
         */
        subject: string;

        /**
         * An HTML template for the email body. Either `html_body` or `visual_blocks` must
         * be provided.
         */
        html_body?: string;

        /**
         * The settings for the email template. Can be omitted.
         */
        settings?: EmailTemplate.Settings | null;

        /**
         * A text template for the email body. Only present if opted out from
         * autogenerating it from the HTML template.
         */
        text_body?: string | null;

        /**
         * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
         * provided.
         */
        visual_blocks?: Array<
          | EmailTemplate.ButtonSetBlock
          | EmailTemplate.DividerBlock
          | EmailTemplate.HTMLBlock
          | EmailTemplate.MarkdownBlock
          | EmailTemplate.PartialBlock
        >;
      }

      export namespace EmailTemplate {
        /**
         * The settings for the email template. Can be omitted.
         */
        export interface Settings {
          /**
           * The object path in the data payload (of the workflow trigger call) to resolve
           * attachments.
           */
          attachment_key?: string | null;

          /**
           * The key of the email layout which the step is using.
           */
          layout_key?: string | null;

          /**
           * A liquid template that will be injected into the layout above the message
           * template content.
           */
          pre_content?: string | null;
        }

        /**
         * A button set block in an email template.
         */
        export interface ButtonSetBlock {
          /**
           * The ID of the block.
           */
          id: string;

          buttons: Array<ButtonSetBlock.Button>;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: ButtonSetBlock.LayoutAttrs;
        }

        export namespace ButtonSetBlock {
          /**
           * A button in a button set block.
           */
          export interface Button {
            action: string;

            label: string;

            variant: string;

            size_attrs?: Button.SizeAttrs;

            style_attrs?: Button.StyleAttrs;
          }

          export namespace Button {
            export interface SizeAttrs {
              is_fullwidth?: boolean;

              size?: 'sm' | 'md' | 'lg';
            }

            export interface StyleAttrs {
              background_color?: string;

              border_color?: string;

              border_radius?: number;

              border_width?: number;

              text_color?: string;
            }
          }

          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            column_gap: number;

            horizontal_align: 'left' | 'center' | 'right';

            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A divider block in an email template.
         */
        export interface DividerBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: DividerBlock.LayoutAttrs;
        }

        export namespace DividerBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * An HTML block in an email template.
         */
        export interface HTMLBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The HTML content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;
        }

        /**
         * A markdown block in an email template.
         */
        export interface MarkdownBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The markdown content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The flavor of markdown to use for the block.
           */
          variant: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: MarkdownBlock.LayoutAttrs;
        }

        export namespace MarkdownBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A partial block in an email template, used to render a reusable partial
         * component.
         */
        export interface PartialBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The attributes to pass to the partial block.
           */
          attrs: Record<string, unknown>;

          /**
           * The key of the partial block to invoke.
           */
          key: string;

          /**
           * The name of the partial block.
           */
          name: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: PartialBlock.LayoutAttrs;
        }

        export namespace PartialBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }
      }

      /**
       * An in-app feed template.
       */
      export interface InAppFeedTemplate {
        /**
         * The markdown body of the in-app feed.
         */
        markdown_body: string;

        /**
         * The action buttons of the in-app feed.
         */
        action_buttons?: Array<InAppFeedTemplate.ActionButton>;

        /**
         * The URL to navigate to when the in-app feed is tapped. Can be omitted for
         * multi-action templates, where the action buttons will be used instead.
         */
        action_url?: string | null;
      }

      export namespace InAppFeedTemplate {
        /**
         * A single-action button to be rendered in an in-app feed cell.
         */
        export interface ActionButton {
          /**
           * The action of the action button.
           */
          action: string;

          /**
           * The label of the action button.
           */
          label: string;
        }
      }

      /**
       * An SMS template.
       */
      export interface SMSTemplate {
        /**
         * The message of the SMS.
         */
        text_body: string;

        /**
         * The settings for the SMS template.
         */
        settings?: SMSTemplate.Settings | null;
      }

      export namespace SMSTemplate {
        /**
         * The settings for the SMS template.
         */
        export interface Settings {
          /**
           * A JSON object overrides the payload sent to the SMS provider.
           */
          payload_overrides?: string | null;

          /**
           * An override for the phone number to send the SMS to. When not set, defaults to
           * `recipient.phone_number`.
           */
          to_number?: string | null;
        }
      }

      /**
       * A push notification template.
       */
      export interface PushTemplate {
        /**
         * The body of the push notification.
         */
        text_body: string;

        /**
         * The title of the push notification.
         */
        title: string;

        /**
         * The settings for the push template. Can be omitted.
         */
        settings?: PushTemplate.Settings | null;
      }

      export namespace PushTemplate {
        /**
         * The settings for the push template. Can be omitted.
         */
        export interface Settings {
          /**
           * The delivery type of the push notification. Defaults to `content`. Set as silent
           * to send a data-only notification. When set to `data`, no body will be sent.
           */
          delivery_type?: 'silent' | 'content';

          /**
           * A JSON object overrides the payload sent to the push provider.
           */
          payload_overrides?: string;
        }
      }

      /**
       * A chat template.
       */
      export interface ChatTemplate {
        /**
         * The markdown body of the chat template.
         */
        markdown_body: string;

        /**
         * A JSON template for the chat notification message payload. Only present if not
         * using the markdown body.
         */
        json_body?: string | null;

        /**
         * The summary of the chat template.
         */
        summary?: string;
      }

      /**
       * A webhook template. By default, a webhook step will use the request settings you
       * configured in your webhook channel. You can override this as you see fit on a
       * per-step basis.
       */
      export interface WebhookTemplate {
        /**
         * The HTTP method of the webhook.
         */
        method: 'get' | 'post' | 'put' | 'delete' | 'patch';

        /**
         * The URL of the webhook.
         */
        url: string;

        /**
         * A body of the request. Only used for POST or PUT requests.
         */
        body?: string | null;

        /**
         * A list of key-value pairs for the request headers. Each object should contain
         * key and value fields with string values.
         */
        headers?: Array<WebhookTemplate.Header>;

        /**
         * A list of key-value pairs for the request query params. Each object should
         * contain key and value fields with string values.
         */
        query_params?: Array<WebhookTemplate.QueryParam>;
      }

      export namespace WebhookTemplate {
        export interface Header {
          /**
           * The key of the header.
           */
          key: string;

          /**
           * The value of the header.
           */
          value: string;
        }

        export interface QueryParam {
          /**
           * The key of the query param.
           */
          key: string;

          /**
           * The value of the query param.
           */
          value: string;
        }
      }

      /**
       * Email channel settings
       */
      export interface EmailChannelSettings {
        /**
         * The BCC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        bcc_address?: string | null;

        /**
         * The CC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        cc_address?: string | null;

        /**
         * The email address from which this channel will send. Supports liquid.
         */
        from_email?: string | null;

        /**
         * The name from which this channel will send. Supports liquid
         */
        from_name?: string | null;

        /**
         * A JSON template for any custom overrides to merge into the API payload that is
         * sent to the email provider. Supports liquid.
         */
        json_overrides?: string | null;

        /**
         * Whether to track link clicks on email notifications.
         */
        link_tracking?: boolean;

        /**
         * Whether to track opens on email notifications.
         */
        open_tracking?: boolean;

        /**
         * The Reply-to address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        reply_to_address?: string | null;

        /**
         * The email address to which this channel will send. Defaults to
         * `recipient.email`. Supports liquid.
         */
        to_address?: string;
      }

      /**
       * In-app feed channel settings
       */
      export interface InAppFeedChannelSettings {
        /**
         * Whether to track link clicks on in-app feed notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * SMS channel settings
       */
      export interface SMSChannelSettings {
        /**
         * Whether to track link clicks on SMS notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * Chat channel settings
       */
      export interface ChatChannelSettings {
        /**
         * Whether to resolve chat provider user IDs using a Knock user's email address.
         * Only relevant for Slack channels for the time being.
         */
        email_based_user_id_resolution?: boolean;

        /**
         * Whether to track link clicks on chat notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * A send window time for a notification. Describes a single day.
       */
      export interface SendWindow {
        day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

        type: 'send' | 'do_not_send';

        from?: string | null;

        until?: string | null;
      }
    }

    /**
     * A delay step within a workflow.
     */
    export interface WorkflowDelayStep {
      /**
       * A group of conditions to be evaluated
       */
      conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      settings: WorkflowDelayStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'delay';
    }

    export namespace WorkflowDelayStep {
      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      export interface Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        delay_for?: Settings.DelayFor | null;

        /**
         * When set will use the path to resolve the delay into a timestamp from the
         * property referenced
         */
        delay_until_field_path?: string;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface DelayFor {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow batch step
     */
    export interface WorkflowBatchStep {
      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the batch step.
       */
      settings: WorkflowBatchStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'batch';
    }

    export namespace WorkflowBatchStep {
      /**
       * The settings for the batch step.
       */
      export interface Settings {
        /**
         * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
         * When set to “flush_leading”, the first item in the batch will be executed
         * immediately, and the rest will be batched.
         */
        batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

        /**
         * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
         */
        batch_items_max_limit?: number | null;

        /**
         * The maximum number of batch items allowed to be rendered into a template.
         * Between: 1 and 100. Defaults to 10.
         */
        batch_items_render_limit?: number | null;

        /**
         * The data property to use to batch notifications per recipient.
         */
        batch_key?: string | null;

        /**
         * The order describing whether to return the first or last ten batch items in the
         * activities variable. One of: “asc” or “desc”.
         */
        batch_order?: 'asc' | 'desc' | null;

        /**
         * The data path to resolve the batch window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        batch_until_field_path?: string | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window?: Settings.BatchWindow | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

        /**
         * The type of the batch window used. One of: “fixed” or “sliding”.
         */
        batch_window_type?: 'fixed' | 'sliding' | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }

        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindowExtensionLimit {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow throttle step
     */
    export interface WorkflowThrottleStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the throttle step.
       */
      settings: WorkflowThrottleStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'throttle';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowThrottleStep.ConditionGroupAllMatch
        | WorkflowThrottleStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;
    }

    export namespace WorkflowThrottleStep {
      /**
       * The settings for the throttle step.
       */
      export interface Settings {
        /**
         * The data property to use to throttle notifications per recipient.
         */
        throttle_key?: string | null;

        /**
         * The maximum number of workflows to allow within the duration window. Defaults
         * to 1.
         */
        throttle_limit?: number | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        throttle_window?: Settings.ThrottleWindow | null;

        /**
         * The data path to resolve the throttle window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        throttle_window_field_path?: string | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface ThrottleWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A workflow trigger workflow step.
     */
    export interface WorkflowTriggerWorkflowStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the workflow trigger workflow step.
       */
      settings: WorkflowTriggerWorkflowStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'trigger_workflow';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
        | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
        | null;

      /**
       * A description for the workflow step.
       */
      description?: string;
    }

    export namespace WorkflowTriggerWorkflowStep {
      /**
       * The settings for the workflow trigger workflow step.
       */
      export interface Settings {
        /**
         * The actor to trigger the workflow with. Supports liquid.
         */
        actor?: string;

        /**
         * The cancellation key to trigger the workflow with. Supports liquid.
         */
        cancellation_key?: string;

        /**
         * The data to be supplied to the workflow. Supports liquid.
         */
        data?: string;

        recipients?: unknown;

        /**
         * The tenant to trigger the workflow with. Supports liquid.
         */
        tenant?: string;

        /**
         * The key of the workflow to trigger. Supports liquid.
         */
        workflow_key?: string;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A map of workflow settings.
     */
    export interface Settings {
      /**
       * Whether the workflow is commercial. Defaults to false.
       */
      is_commercial?: boolean;

      /**
       * Whether to ignore recipient preferences for a given type of notification. If
       * true, will send for every channel in the workflow even if the recipient has
       * opted out of a certain kind. Defaults to false.
       */
      override_preferences?: boolean;
    }
  }
}

/**
 * A response to a run workflow request.
 */
export interface WorkflowRunResponse {
  /**
   * The ID of the workflow run.
   */
  workflow_run_id: string;
}

/**
 * Wraps the Workflow response under the workflow key.
 */
export interface WorkflowUpsertResponse {
  /**
   * A workflow object.
   */
  workflow: WorkflowUpsertResponse.Workflow;
}

export namespace WorkflowUpsertResponse {
  /**
   * A workflow object.
   */
  export interface Workflow {
    /**
     * Whether the workflow is active in the current environment. (read-only)
     */
    active: boolean;

    /**
     * A timestamp of when the workflow was created. (read-only)
     */
    created_at: string;

    /**
     * The slug of the environment in which the workflow exists. (read-only)
     */
    environment: string;

    /**
     * The unique key string for the workflow object. Must be at minimum 3 characters
     * and at maximum 255 characters in length. Must be in the format of ^[a-z0-9_-]+$.
     */
    key: string;

    /**
     * A name for the workflow. Must be at maximum 255 characters in length.
     */
    name: string;

    /**
     * The SHA hash of the workflow data. (read-only)
     */
    sha: string;

    /**
     * A list of workflow step objects in the workflow, which may contain any of:
     * channel step, delay step, batch step, fetch step.
     */
    steps: Array<
      | Workflow.WorkflowChannelStep
      | Workflow.WorkflowDelayStep
      | Workflow.WorkflowBatchStep
      | Workflow.WorkflowThrottleStep
      | unknown
      | Workflow.WorkflowTriggerWorkflowStep
    >;

    /**
     * A timestamp of when the workflow was last updated. (read-only)
     */
    updated_at: string;

    /**
     * Whether the workflow and its steps are in a valid state. (read-only)
     */
    valid: boolean;

    /**
     * A list of categories that the workflow belongs to.
     */
    categories?: Array<string>;

    /**
     * A group of conditions to be evaluated
     */
    conditions?: Workflow.ConditionGroupAllMatch | Workflow.ConditionGroupAnyMatch | null;

    /**
     * A timestamp of when the workflow was deleted. (read-only)
     */
    deleted_at?: string;

    /**
     * An arbitrary string attached to a workflow object. Useful for adding notes about
     * the workflow for internal purposes. Maximum of 280 characters allowed.
     */
    description?: string;

    /**
     * A map of workflow settings.
     */
    settings?: Workflow.Settings;

    /**
     * A JSON schema for the expected structure of the workflow trigger's data payload.
     * Used to validate trigger requests. (optional)
     */
    trigger_data_json_schema?: unknown;

    /**
     * The frequency at which the workflow should be triggered. One of:
     * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
     * to "every_trigger".
     */
    trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
  }

  export namespace Workflow {
    /**
     * A channel step within a workflow.
     */
    export interface WorkflowChannelStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The message template set up with the channel step. The shape of the template
       * depends on the type of the channel you'll be sending to. See below for
       * definitions of each channel type template: email, in-app, SMS, push, chat, and
       * webhook.
       */
      template:
        | WorkflowChannelStep.EmailTemplate
        | WorkflowChannelStep.InAppFeedTemplate
        | WorkflowChannelStep.SMSTemplate
        | WorkflowChannelStep.PushTemplate
        | WorkflowChannelStep.ChatTemplate
        | WorkflowChannelStep.WebhookTemplate;

      /**
       * The type of the workflow step.
       */
      type: 'channel';

      /**
       * The key of the channel group to which the channel step will be sending a
       * notification. A channel step can have either a channel key or a channel group
       * key, but not both.
       */
      channel_group_key?: string | null;

      /**
       * The key of the channel to which the channel step will be sending a notification.
       * A channel step can have either a channel key or a channel group key, but not
       * both.
       */
      channel_key?: string | null;

      /**
       * A map of channel overrides for the channel step.
       */
      channel_overrides?:
        | WorkflowChannelStep.EmailChannelSettings
        | WorkflowChannelStep.InAppFeedChannelSettings
        | WorkflowChannelStep.SMSChannelSettings
        | WorkflowChannelStep.ChatChannelSettings
        | null;

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowChannelStep.ConditionGroupAllMatch
        | WorkflowChannelStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;

      /**
       * A list of send window objects. Must include one send window object per day of
       * the week.
       */
      send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
    }

    export namespace WorkflowChannelStep {
      /**
       * An email message template.
       */
      export interface EmailTemplate {
        /**
         * The subject of the email.
         */
        subject: string;

        /**
         * An HTML template for the email body. Either `html_body` or `visual_blocks` must
         * be provided.
         */
        html_body?: string;

        /**
         * The settings for the email template. Can be omitted.
         */
        settings?: EmailTemplate.Settings | null;

        /**
         * A text template for the email body. Only present if opted out from
         * autogenerating it from the HTML template.
         */
        text_body?: string | null;

        /**
         * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
         * provided.
         */
        visual_blocks?: Array<
          | EmailTemplate.ButtonSetBlock
          | EmailTemplate.DividerBlock
          | EmailTemplate.HTMLBlock
          | EmailTemplate.MarkdownBlock
          | EmailTemplate.PartialBlock
        >;
      }

      export namespace EmailTemplate {
        /**
         * The settings for the email template. Can be omitted.
         */
        export interface Settings {
          /**
           * The object path in the data payload (of the workflow trigger call) to resolve
           * attachments.
           */
          attachment_key?: string | null;

          /**
           * The key of the email layout which the step is using.
           */
          layout_key?: string | null;

          /**
           * A liquid template that will be injected into the layout above the message
           * template content.
           */
          pre_content?: string | null;
        }

        /**
         * A button set block in an email template.
         */
        export interface ButtonSetBlock {
          /**
           * The ID of the block.
           */
          id: string;

          buttons: Array<ButtonSetBlock.Button>;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: ButtonSetBlock.LayoutAttrs;
        }

        export namespace ButtonSetBlock {
          /**
           * A button in a button set block.
           */
          export interface Button {
            action: string;

            label: string;

            variant: string;

            size_attrs?: Button.SizeAttrs;

            style_attrs?: Button.StyleAttrs;
          }

          export namespace Button {
            export interface SizeAttrs {
              is_fullwidth?: boolean;

              size?: 'sm' | 'md' | 'lg';
            }

            export interface StyleAttrs {
              background_color?: string;

              border_color?: string;

              border_radius?: number;

              border_width?: number;

              text_color?: string;
            }
          }

          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            column_gap: number;

            horizontal_align: 'left' | 'center' | 'right';

            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A divider block in an email template.
         */
        export interface DividerBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: DividerBlock.LayoutAttrs;
        }

        export namespace DividerBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * An HTML block in an email template.
         */
        export interface HTMLBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The HTML content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;
        }

        /**
         * A markdown block in an email template.
         */
        export interface MarkdownBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The markdown content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The flavor of markdown to use for the block.
           */
          variant: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: MarkdownBlock.LayoutAttrs;
        }

        export namespace MarkdownBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A partial block in an email template, used to render a reusable partial
         * component.
         */
        export interface PartialBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The attributes to pass to the partial block.
           */
          attrs: Record<string, unknown>;

          /**
           * The key of the partial block to invoke.
           */
          key: string;

          /**
           * The name of the partial block.
           */
          name: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: PartialBlock.LayoutAttrs;
        }

        export namespace PartialBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }
      }

      /**
       * An in-app feed template.
       */
      export interface InAppFeedTemplate {
        /**
         * The markdown body of the in-app feed.
         */
        markdown_body: string;

        /**
         * The action buttons of the in-app feed.
         */
        action_buttons?: Array<InAppFeedTemplate.ActionButton>;

        /**
         * The URL to navigate to when the in-app feed is tapped. Can be omitted for
         * multi-action templates, where the action buttons will be used instead.
         */
        action_url?: string | null;
      }

      export namespace InAppFeedTemplate {
        /**
         * A single-action button to be rendered in an in-app feed cell.
         */
        export interface ActionButton {
          /**
           * The action of the action button.
           */
          action: string;

          /**
           * The label of the action button.
           */
          label: string;
        }
      }

      /**
       * An SMS template.
       */
      export interface SMSTemplate {
        /**
         * The message of the SMS.
         */
        text_body: string;

        /**
         * The settings for the SMS template.
         */
        settings?: SMSTemplate.Settings | null;
      }

      export namespace SMSTemplate {
        /**
         * The settings for the SMS template.
         */
        export interface Settings {
          /**
           * A JSON object overrides the payload sent to the SMS provider.
           */
          payload_overrides?: string | null;

          /**
           * An override for the phone number to send the SMS to. When not set, defaults to
           * `recipient.phone_number`.
           */
          to_number?: string | null;
        }
      }

      /**
       * A push notification template.
       */
      export interface PushTemplate {
        /**
         * The body of the push notification.
         */
        text_body: string;

        /**
         * The title of the push notification.
         */
        title: string;

        /**
         * The settings for the push template. Can be omitted.
         */
        settings?: PushTemplate.Settings | null;
      }

      export namespace PushTemplate {
        /**
         * The settings for the push template. Can be omitted.
         */
        export interface Settings {
          /**
           * The delivery type of the push notification. Defaults to `content`. Set as silent
           * to send a data-only notification. When set to `data`, no body will be sent.
           */
          delivery_type?: 'silent' | 'content';

          /**
           * A JSON object overrides the payload sent to the push provider.
           */
          payload_overrides?: string;
        }
      }

      /**
       * A chat template.
       */
      export interface ChatTemplate {
        /**
         * The markdown body of the chat template.
         */
        markdown_body: string;

        /**
         * A JSON template for the chat notification message payload. Only present if not
         * using the markdown body.
         */
        json_body?: string | null;

        /**
         * The summary of the chat template.
         */
        summary?: string;
      }

      /**
       * A webhook template. By default, a webhook step will use the request settings you
       * configured in your webhook channel. You can override this as you see fit on a
       * per-step basis.
       */
      export interface WebhookTemplate {
        /**
         * The HTTP method of the webhook.
         */
        method: 'get' | 'post' | 'put' | 'delete' | 'patch';

        /**
         * The URL of the webhook.
         */
        url: string;

        /**
         * A body of the request. Only used for POST or PUT requests.
         */
        body?: string | null;

        /**
         * A list of key-value pairs for the request headers. Each object should contain
         * key and value fields with string values.
         */
        headers?: Array<WebhookTemplate.Header>;

        /**
         * A list of key-value pairs for the request query params. Each object should
         * contain key and value fields with string values.
         */
        query_params?: Array<WebhookTemplate.QueryParam>;
      }

      export namespace WebhookTemplate {
        export interface Header {
          /**
           * The key of the header.
           */
          key: string;

          /**
           * The value of the header.
           */
          value: string;
        }

        export interface QueryParam {
          /**
           * The key of the query param.
           */
          key: string;

          /**
           * The value of the query param.
           */
          value: string;
        }
      }

      /**
       * Email channel settings
       */
      export interface EmailChannelSettings {
        /**
         * The BCC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        bcc_address?: string | null;

        /**
         * The CC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        cc_address?: string | null;

        /**
         * The email address from which this channel will send. Supports liquid.
         */
        from_email?: string | null;

        /**
         * The name from which this channel will send. Supports liquid
         */
        from_name?: string | null;

        /**
         * A JSON template for any custom overrides to merge into the API payload that is
         * sent to the email provider. Supports liquid.
         */
        json_overrides?: string | null;

        /**
         * Whether to track link clicks on email notifications.
         */
        link_tracking?: boolean;

        /**
         * Whether to track opens on email notifications.
         */
        open_tracking?: boolean;

        /**
         * The Reply-to address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        reply_to_address?: string | null;

        /**
         * The email address to which this channel will send. Defaults to
         * `recipient.email`. Supports liquid.
         */
        to_address?: string;
      }

      /**
       * In-app feed channel settings
       */
      export interface InAppFeedChannelSettings {
        /**
         * Whether to track link clicks on in-app feed notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * SMS channel settings
       */
      export interface SMSChannelSettings {
        /**
         * Whether to track link clicks on SMS notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * Chat channel settings
       */
      export interface ChatChannelSettings {
        /**
         * Whether to resolve chat provider user IDs using a Knock user's email address.
         * Only relevant for Slack channels for the time being.
         */
        email_based_user_id_resolution?: boolean;

        /**
         * Whether to track link clicks on chat notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * A send window time for a notification. Describes a single day.
       */
      export interface SendWindow {
        day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

        type: 'send' | 'do_not_send';

        from?: string | null;

        until?: string | null;
      }
    }

    /**
     * A delay step within a workflow.
     */
    export interface WorkflowDelayStep {
      /**
       * A group of conditions to be evaluated
       */
      conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      settings: WorkflowDelayStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'delay';
    }

    export namespace WorkflowDelayStep {
      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      export interface Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        delay_for?: Settings.DelayFor | null;

        /**
         * When set will use the path to resolve the delay into a timestamp from the
         * property referenced
         */
        delay_until_field_path?: string;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface DelayFor {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow batch step
     */
    export interface WorkflowBatchStep {
      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the batch step.
       */
      settings: WorkflowBatchStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'batch';
    }

    export namespace WorkflowBatchStep {
      /**
       * The settings for the batch step.
       */
      export interface Settings {
        /**
         * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
         * When set to “flush_leading”, the first item in the batch will be executed
         * immediately, and the rest will be batched.
         */
        batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

        /**
         * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
         */
        batch_items_max_limit?: number | null;

        /**
         * The maximum number of batch items allowed to be rendered into a template.
         * Between: 1 and 100. Defaults to 10.
         */
        batch_items_render_limit?: number | null;

        /**
         * The data property to use to batch notifications per recipient.
         */
        batch_key?: string | null;

        /**
         * The order describing whether to return the first or last ten batch items in the
         * activities variable. One of: “asc” or “desc”.
         */
        batch_order?: 'asc' | 'desc' | null;

        /**
         * The data path to resolve the batch window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        batch_until_field_path?: string | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window?: Settings.BatchWindow | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

        /**
         * The type of the batch window used. One of: “fixed” or “sliding”.
         */
        batch_window_type?: 'fixed' | 'sliding' | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }

        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindowExtensionLimit {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow throttle step
     */
    export interface WorkflowThrottleStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the throttle step.
       */
      settings: WorkflowThrottleStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'throttle';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowThrottleStep.ConditionGroupAllMatch
        | WorkflowThrottleStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;
    }

    export namespace WorkflowThrottleStep {
      /**
       * The settings for the throttle step.
       */
      export interface Settings {
        /**
         * The data property to use to throttle notifications per recipient.
         */
        throttle_key?: string | null;

        /**
         * The maximum number of workflows to allow within the duration window. Defaults
         * to 1.
         */
        throttle_limit?: number | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        throttle_window?: Settings.ThrottleWindow | null;

        /**
         * The data path to resolve the throttle window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        throttle_window_field_path?: string | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface ThrottleWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A workflow trigger workflow step.
     */
    export interface WorkflowTriggerWorkflowStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the workflow trigger workflow step.
       */
      settings: WorkflowTriggerWorkflowStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'trigger_workflow';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
        | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
        | null;

      /**
       * A description for the workflow step.
       */
      description?: string;
    }

    export namespace WorkflowTriggerWorkflowStep {
      /**
       * The settings for the workflow trigger workflow step.
       */
      export interface Settings {
        /**
         * The actor to trigger the workflow with. Supports liquid.
         */
        actor?: string;

        /**
         * The cancellation key to trigger the workflow with. Supports liquid.
         */
        cancellation_key?: string;

        /**
         * The data to be supplied to the workflow. Supports liquid.
         */
        data?: string;

        recipients?: unknown;

        /**
         * The tenant to trigger the workflow with. Supports liquid.
         */
        tenant?: string;

        /**
         * The key of the workflow to trigger. Supports liquid.
         */
        workflow_key?: string;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A map of workflow settings.
     */
    export interface Settings {
      /**
       * Whether the workflow is commercial. Defaults to false.
       */
      is_commercial?: boolean;

      /**
       * Whether to ignore recipient preferences for a given type of notification. If
       * true, will send for every channel in the workflow even if the recipient has
       * opted out of a certain kind. Defaults to false.
       */
      override_preferences?: boolean;
    }
  }
}

/**
 * Wraps the Workflow response under the workflow key.
 */
export interface WorkflowValidateResponse {
  /**
   * A workflow object.
   */
  workflow: WorkflowValidateResponse.Workflow;
}

export namespace WorkflowValidateResponse {
  /**
   * A workflow object.
   */
  export interface Workflow {
    /**
     * Whether the workflow is active in the current environment. (read-only)
     */
    active: boolean;

    /**
     * A timestamp of when the workflow was created. (read-only)
     */
    created_at: string;

    /**
     * The slug of the environment in which the workflow exists. (read-only)
     */
    environment: string;

    /**
     * The unique key string for the workflow object. Must be at minimum 3 characters
     * and at maximum 255 characters in length. Must be in the format of ^[a-z0-9_-]+$.
     */
    key: string;

    /**
     * A name for the workflow. Must be at maximum 255 characters in length.
     */
    name: string;

    /**
     * The SHA hash of the workflow data. (read-only)
     */
    sha: string;

    /**
     * A list of workflow step objects in the workflow, which may contain any of:
     * channel step, delay step, batch step, fetch step.
     */
    steps: Array<
      | Workflow.WorkflowChannelStep
      | Workflow.WorkflowDelayStep
      | Workflow.WorkflowBatchStep
      | Workflow.WorkflowThrottleStep
      | unknown
      | Workflow.WorkflowTriggerWorkflowStep
    >;

    /**
     * A timestamp of when the workflow was last updated. (read-only)
     */
    updated_at: string;

    /**
     * Whether the workflow and its steps are in a valid state. (read-only)
     */
    valid: boolean;

    /**
     * A list of categories that the workflow belongs to.
     */
    categories?: Array<string>;

    /**
     * A group of conditions to be evaluated
     */
    conditions?: Workflow.ConditionGroupAllMatch | Workflow.ConditionGroupAnyMatch | null;

    /**
     * A timestamp of when the workflow was deleted. (read-only)
     */
    deleted_at?: string;

    /**
     * An arbitrary string attached to a workflow object. Useful for adding notes about
     * the workflow for internal purposes. Maximum of 280 characters allowed.
     */
    description?: string;

    /**
     * A map of workflow settings.
     */
    settings?: Workflow.Settings;

    /**
     * A JSON schema for the expected structure of the workflow trigger's data payload.
     * Used to validate trigger requests. (optional)
     */
    trigger_data_json_schema?: unknown;

    /**
     * The frequency at which the workflow should be triggered. One of:
     * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
     * to "every_trigger".
     */
    trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
  }

  export namespace Workflow {
    /**
     * A channel step within a workflow.
     */
    export interface WorkflowChannelStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The message template set up with the channel step. The shape of the template
       * depends on the type of the channel you'll be sending to. See below for
       * definitions of each channel type template: email, in-app, SMS, push, chat, and
       * webhook.
       */
      template:
        | WorkflowChannelStep.EmailTemplate
        | WorkflowChannelStep.InAppFeedTemplate
        | WorkflowChannelStep.SMSTemplate
        | WorkflowChannelStep.PushTemplate
        | WorkflowChannelStep.ChatTemplate
        | WorkflowChannelStep.WebhookTemplate;

      /**
       * The type of the workflow step.
       */
      type: 'channel';

      /**
       * The key of the channel group to which the channel step will be sending a
       * notification. A channel step can have either a channel key or a channel group
       * key, but not both.
       */
      channel_group_key?: string | null;

      /**
       * The key of the channel to which the channel step will be sending a notification.
       * A channel step can have either a channel key or a channel group key, but not
       * both.
       */
      channel_key?: string | null;

      /**
       * A map of channel overrides for the channel step.
       */
      channel_overrides?:
        | WorkflowChannelStep.EmailChannelSettings
        | WorkflowChannelStep.InAppFeedChannelSettings
        | WorkflowChannelStep.SMSChannelSettings
        | WorkflowChannelStep.ChatChannelSettings
        | null;

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowChannelStep.ConditionGroupAllMatch
        | WorkflowChannelStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;

      /**
       * A list of send window objects. Must include one send window object per day of
       * the week.
       */
      send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
    }

    export namespace WorkflowChannelStep {
      /**
       * An email message template.
       */
      export interface EmailTemplate {
        /**
         * The subject of the email.
         */
        subject: string;

        /**
         * An HTML template for the email body. Either `html_body` or `visual_blocks` must
         * be provided.
         */
        html_body?: string;

        /**
         * The settings for the email template. Can be omitted.
         */
        settings?: EmailTemplate.Settings | null;

        /**
         * A text template for the email body. Only present if opted out from
         * autogenerating it from the HTML template.
         */
        text_body?: string | null;

        /**
         * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
         * provided.
         */
        visual_blocks?: Array<
          | EmailTemplate.ButtonSetBlock
          | EmailTemplate.DividerBlock
          | EmailTemplate.HTMLBlock
          | EmailTemplate.MarkdownBlock
          | EmailTemplate.PartialBlock
        >;
      }

      export namespace EmailTemplate {
        /**
         * The settings for the email template. Can be omitted.
         */
        export interface Settings {
          /**
           * The object path in the data payload (of the workflow trigger call) to resolve
           * attachments.
           */
          attachment_key?: string | null;

          /**
           * The key of the email layout which the step is using.
           */
          layout_key?: string | null;

          /**
           * A liquid template that will be injected into the layout above the message
           * template content.
           */
          pre_content?: string | null;
        }

        /**
         * A button set block in an email template.
         */
        export interface ButtonSetBlock {
          /**
           * The ID of the block.
           */
          id: string;

          buttons: Array<ButtonSetBlock.Button>;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: ButtonSetBlock.LayoutAttrs;
        }

        export namespace ButtonSetBlock {
          /**
           * A button in a button set block.
           */
          export interface Button {
            action: string;

            label: string;

            variant: string;

            size_attrs?: Button.SizeAttrs;

            style_attrs?: Button.StyleAttrs;
          }

          export namespace Button {
            export interface SizeAttrs {
              is_fullwidth?: boolean;

              size?: 'sm' | 'md' | 'lg';
            }

            export interface StyleAttrs {
              background_color?: string;

              border_color?: string;

              border_radius?: number;

              border_width?: number;

              text_color?: string;
            }
          }

          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            column_gap: number;

            horizontal_align: 'left' | 'center' | 'right';

            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A divider block in an email template.
         */
        export interface DividerBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: DividerBlock.LayoutAttrs;
        }

        export namespace DividerBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * An HTML block in an email template.
         */
        export interface HTMLBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The HTML content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;
        }

        /**
         * A markdown block in an email template.
         */
        export interface MarkdownBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The markdown content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The flavor of markdown to use for the block.
           */
          variant: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: MarkdownBlock.LayoutAttrs;
        }

        export namespace MarkdownBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A partial block in an email template, used to render a reusable partial
         * component.
         */
        export interface PartialBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The attributes to pass to the partial block.
           */
          attrs: Record<string, unknown>;

          /**
           * The key of the partial block to invoke.
           */
          key: string;

          /**
           * The name of the partial block.
           */
          name: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: PartialBlock.LayoutAttrs;
        }

        export namespace PartialBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }
      }

      /**
       * An in-app feed template.
       */
      export interface InAppFeedTemplate {
        /**
         * The markdown body of the in-app feed.
         */
        markdown_body: string;

        /**
         * The action buttons of the in-app feed.
         */
        action_buttons?: Array<InAppFeedTemplate.ActionButton>;

        /**
         * The URL to navigate to when the in-app feed is tapped. Can be omitted for
         * multi-action templates, where the action buttons will be used instead.
         */
        action_url?: string | null;
      }

      export namespace InAppFeedTemplate {
        /**
         * A single-action button to be rendered in an in-app feed cell.
         */
        export interface ActionButton {
          /**
           * The action of the action button.
           */
          action: string;

          /**
           * The label of the action button.
           */
          label: string;
        }
      }

      /**
       * An SMS template.
       */
      export interface SMSTemplate {
        /**
         * The message of the SMS.
         */
        text_body: string;

        /**
         * The settings for the SMS template.
         */
        settings?: SMSTemplate.Settings | null;
      }

      export namespace SMSTemplate {
        /**
         * The settings for the SMS template.
         */
        export interface Settings {
          /**
           * A JSON object overrides the payload sent to the SMS provider.
           */
          payload_overrides?: string | null;

          /**
           * An override for the phone number to send the SMS to. When not set, defaults to
           * `recipient.phone_number`.
           */
          to_number?: string | null;
        }
      }

      /**
       * A push notification template.
       */
      export interface PushTemplate {
        /**
         * The body of the push notification.
         */
        text_body: string;

        /**
         * The title of the push notification.
         */
        title: string;

        /**
         * The settings for the push template. Can be omitted.
         */
        settings?: PushTemplate.Settings | null;
      }

      export namespace PushTemplate {
        /**
         * The settings for the push template. Can be omitted.
         */
        export interface Settings {
          /**
           * The delivery type of the push notification. Defaults to `content`. Set as silent
           * to send a data-only notification. When set to `data`, no body will be sent.
           */
          delivery_type?: 'silent' | 'content';

          /**
           * A JSON object overrides the payload sent to the push provider.
           */
          payload_overrides?: string;
        }
      }

      /**
       * A chat template.
       */
      export interface ChatTemplate {
        /**
         * The markdown body of the chat template.
         */
        markdown_body: string;

        /**
         * A JSON template for the chat notification message payload. Only present if not
         * using the markdown body.
         */
        json_body?: string | null;

        /**
         * The summary of the chat template.
         */
        summary?: string;
      }

      /**
       * A webhook template. By default, a webhook step will use the request settings you
       * configured in your webhook channel. You can override this as you see fit on a
       * per-step basis.
       */
      export interface WebhookTemplate {
        /**
         * The HTTP method of the webhook.
         */
        method: 'get' | 'post' | 'put' | 'delete' | 'patch';

        /**
         * The URL of the webhook.
         */
        url: string;

        /**
         * A body of the request. Only used for POST or PUT requests.
         */
        body?: string | null;

        /**
         * A list of key-value pairs for the request headers. Each object should contain
         * key and value fields with string values.
         */
        headers?: Array<WebhookTemplate.Header>;

        /**
         * A list of key-value pairs for the request query params. Each object should
         * contain key and value fields with string values.
         */
        query_params?: Array<WebhookTemplate.QueryParam>;
      }

      export namespace WebhookTemplate {
        export interface Header {
          /**
           * The key of the header.
           */
          key: string;

          /**
           * The value of the header.
           */
          value: string;
        }

        export interface QueryParam {
          /**
           * The key of the query param.
           */
          key: string;

          /**
           * The value of the query param.
           */
          value: string;
        }
      }

      /**
       * Email channel settings
       */
      export interface EmailChannelSettings {
        /**
         * The BCC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        bcc_address?: string | null;

        /**
         * The CC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        cc_address?: string | null;

        /**
         * The email address from which this channel will send. Supports liquid.
         */
        from_email?: string | null;

        /**
         * The name from which this channel will send. Supports liquid
         */
        from_name?: string | null;

        /**
         * A JSON template for any custom overrides to merge into the API payload that is
         * sent to the email provider. Supports liquid.
         */
        json_overrides?: string | null;

        /**
         * Whether to track link clicks on email notifications.
         */
        link_tracking?: boolean;

        /**
         * Whether to track opens on email notifications.
         */
        open_tracking?: boolean;

        /**
         * The Reply-to address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        reply_to_address?: string | null;

        /**
         * The email address to which this channel will send. Defaults to
         * `recipient.email`. Supports liquid.
         */
        to_address?: string;
      }

      /**
       * In-app feed channel settings
       */
      export interface InAppFeedChannelSettings {
        /**
         * Whether to track link clicks on in-app feed notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * SMS channel settings
       */
      export interface SMSChannelSettings {
        /**
         * Whether to track link clicks on SMS notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * Chat channel settings
       */
      export interface ChatChannelSettings {
        /**
         * Whether to resolve chat provider user IDs using a Knock user's email address.
         * Only relevant for Slack channels for the time being.
         */
        email_based_user_id_resolution?: boolean;

        /**
         * Whether to track link clicks on chat notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * A send window time for a notification. Describes a single day.
       */
      export interface SendWindow {
        day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

        type: 'send' | 'do_not_send';

        from?: string | null;

        until?: string | null;
      }
    }

    /**
     * A delay step within a workflow.
     */
    export interface WorkflowDelayStep {
      /**
       * A group of conditions to be evaluated
       */
      conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      settings: WorkflowDelayStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'delay';
    }

    export namespace WorkflowDelayStep {
      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      export interface Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        delay_for?: Settings.DelayFor | null;

        /**
         * When set will use the path to resolve the delay into a timestamp from the
         * property referenced
         */
        delay_until_field_path?: string;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface DelayFor {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow batch step
     */
    export interface WorkflowBatchStep {
      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the batch step.
       */
      settings: WorkflowBatchStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'batch';
    }

    export namespace WorkflowBatchStep {
      /**
       * The settings for the batch step.
       */
      export interface Settings {
        /**
         * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
         * When set to “flush_leading”, the first item in the batch will be executed
         * immediately, and the rest will be batched.
         */
        batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

        /**
         * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
         */
        batch_items_max_limit?: number | null;

        /**
         * The maximum number of batch items allowed to be rendered into a template.
         * Between: 1 and 100. Defaults to 10.
         */
        batch_items_render_limit?: number | null;

        /**
         * The data property to use to batch notifications per recipient.
         */
        batch_key?: string | null;

        /**
         * The order describing whether to return the first or last ten batch items in the
         * activities variable. One of: “asc” or “desc”.
         */
        batch_order?: 'asc' | 'desc' | null;

        /**
         * The data path to resolve the batch window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        batch_until_field_path?: string | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window?: Settings.BatchWindow | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

        /**
         * The type of the batch window used. One of: “fixed” or “sliding”.
         */
        batch_window_type?: 'fixed' | 'sliding' | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }

        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindowExtensionLimit {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow throttle step
     */
    export interface WorkflowThrottleStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the throttle step.
       */
      settings: WorkflowThrottleStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'throttle';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowThrottleStep.ConditionGroupAllMatch
        | WorkflowThrottleStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;
    }

    export namespace WorkflowThrottleStep {
      /**
       * The settings for the throttle step.
       */
      export interface Settings {
        /**
         * The data property to use to throttle notifications per recipient.
         */
        throttle_key?: string | null;

        /**
         * The maximum number of workflows to allow within the duration window. Defaults
         * to 1.
         */
        throttle_limit?: number | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        throttle_window?: Settings.ThrottleWindow | null;

        /**
         * The data path to resolve the throttle window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        throttle_window_field_path?: string | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface ThrottleWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A workflow trigger workflow step.
     */
    export interface WorkflowTriggerWorkflowStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the workflow trigger workflow step.
       */
      settings: WorkflowTriggerWorkflowStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'trigger_workflow';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
        | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
        | null;

      /**
       * A description for the workflow step.
       */
      description?: string;
    }

    export namespace WorkflowTriggerWorkflowStep {
      /**
       * The settings for the workflow trigger workflow step.
       */
      export interface Settings {
        /**
         * The actor to trigger the workflow with. Supports liquid.
         */
        actor?: string;

        /**
         * The cancellation key to trigger the workflow with. Supports liquid.
         */
        cancellation_key?: string;

        /**
         * The data to be supplied to the workflow. Supports liquid.
         */
        data?: string;

        recipients?: unknown;

        /**
         * The tenant to trigger the workflow with. Supports liquid.
         */
        tenant?: string;

        /**
         * The key of the workflow to trigger. Supports liquid.
         */
        workflow_key?: string;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A map of workflow settings.
     */
    export interface Settings {
      /**
       * Whether the workflow is commercial. Defaults to false.
       */
      is_commercial?: boolean;

      /**
       * Whether to ignore recipient preferences for a given type of notification. If
       * true, will send for every channel in the workflow even if the recipient has
       * opted out of a certain kind. Defaults to false.
       */
      override_preferences?: boolean;
    }
  }
}

export interface WorkflowRetrieveParams {
  /**
   * A slug of the environment from which to query workflows.
   */
  environment: string;

  /**
   * Whether to annotate the resource
   */
  annotate?: boolean;

  /**
   * Whether to hide uncommitted changes
   */
  hide_uncommitted_changes?: boolean;
}

export interface WorkflowListParams {
  /**
   * A slug of the environment from which to query workflows.
   */
  environment: string;

  /**
   * The cursor to fetch entries after
   */
  after?: string;

  /**
   * Whether to annotate the resource
   */
  annotate?: boolean;

  /**
   * The cursor to fetch entries before
   */
  before?: string;

  /**
   * Whether to hide uncommitted changes
   */
  hide_uncommitted_changes?: boolean;

  /**
   * The number of entries to fetch
   */
  limit?: number;
}

export interface WorkflowActivateParams {
  /**
   * Query param: The environment slug. (Defaults to `development`.)
   */
  environment: string;

  /**
   * Body param: Whether to activate or deactivate the workflow. Set to “true” by
   * default, which will activate the workflow.
   */
  status: boolean;
}

export interface WorkflowRunParams {
  /**
   * Query param: The environment slug. (Defaults to `development`.)
   */
  environment: string;

  /**
   * Body param: A list of recipients to run the workflow for.
   */
  recipients: Array<string | WorkflowRunParams.UnionMember1>;

  /**
   * Body param: A recipient reference, used when referencing a recipient by either
   * their ID (for a user), or by a reference for an object.
   */
  actor?: string | WorkflowRunParams.UnionMember1 | null;

  /**
   * Body param: A key to cancel the workflow run.
   */
  cancellation_key?: string | null;

  /**
   * Body param: A map of data to be used in the workflow run.
   */
  data?: Record<string, unknown>;

  /**
   * Body param: The tenant to associate the workflow run with.
   */
  tenant?: string;
}

export namespace WorkflowRunParams {
  /**
   * An object reference
   */
  export interface UnionMember1 {
    id: string;

    collection: string;
  }

  /**
   * An object reference
   */
  export interface UnionMember1 {
    id: string;

    collection: string;
  }
}

export interface WorkflowUpsertParams {
  /**
   * Query param: A slug of the environment in which to upsert the workflow.
   */
  environment: string;

  /**
   * Body param: A workflow request for upserting a workflow.
   */
  workflow: WorkflowUpsertParams.Workflow;

  /**
   * Query param: Whether to commit the resource at the same time as modifying it
   */
  commit?: boolean;

  /**
   * Query param: The message to commit the resource with
   */
  commit_message?: string;
}

export namespace WorkflowUpsertParams {
  /**
   * A workflow request for upserting a workflow.
   */
  export interface Workflow {
    /**
     * A name for the workflow. Must be at maximum 255 characters in length.
     */
    name: string;

    /**
     * A list of workflow step objects in the workflow, which may contain any of:
     * channel step, delay step, batch step, fetch step.
     */
    steps: Array<
      | Workflow.WorkflowChannelStep
      | Workflow.WorkflowDelayStep
      | Workflow.WorkflowBatchStep
      | Workflow.WorkflowThrottleStep
      | unknown
      | Workflow.WorkflowTriggerWorkflowStep
    >;

    /**
     * A list of categories that the workflow belongs to.
     */
    categories?: Array<string>;

    /**
     * A group of conditions to be evaluated
     */
    conditions?: Workflow.ConditionGroupAllMatch | Workflow.ConditionGroupAnyMatch | null;

    /**
     * An arbitrary string attached to a workflow object. Useful for adding notes about
     * the workflow for internal purposes. Maximum of 280 characters allowed.
     */
    description?: string;

    /**
     * A map of workflow settings.
     */
    settings?: Workflow.Settings;

    /**
     * A JSON schema for the expected structure of the workflow trigger's data payload.
     * Used to validate trigger requests. (optional)
     */
    trigger_data_json_schema?: unknown;

    /**
     * The frequency at which the workflow should be triggered. One of:
     * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
     * to "every_trigger".
     */
    trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
  }

  export namespace Workflow {
    /**
     * A channel step within a workflow.
     */
    export interface WorkflowChannelStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The message template set up with the channel step. The shape of the template
       * depends on the type of the channel you'll be sending to. See below for
       * definitions of each channel type template: email, in-app, SMS, push, chat, and
       * webhook.
       */
      template:
        | WorkflowChannelStep.EmailTemplate
        | WorkflowChannelStep.InAppFeedTemplate
        | WorkflowChannelStep.SMSTemplate
        | WorkflowChannelStep.PushTemplate
        | WorkflowChannelStep.ChatTemplate
        | WorkflowChannelStep.WebhookTemplate;

      /**
       * The type of the workflow step.
       */
      type: 'channel';

      /**
       * The key of the channel group to which the channel step will be sending a
       * notification. A channel step can have either a channel key or a channel group
       * key, but not both.
       */
      channel_group_key?: string | null;

      /**
       * The key of the channel to which the channel step will be sending a notification.
       * A channel step can have either a channel key or a channel group key, but not
       * both.
       */
      channel_key?: string | null;

      /**
       * A map of channel overrides for the channel step.
       */
      channel_overrides?:
        | WorkflowChannelStep.EmailChannelSettings
        | WorkflowChannelStep.InAppFeedChannelSettings
        | WorkflowChannelStep.SMSChannelSettings
        | WorkflowChannelStep.ChatChannelSettings
        | null;

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowChannelStep.ConditionGroupAllMatch
        | WorkflowChannelStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;

      /**
       * A list of send window objects. Must include one send window object per day of
       * the week.
       */
      send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
    }

    export namespace WorkflowChannelStep {
      /**
       * An email message template.
       */
      export interface EmailTemplate {
        /**
         * The subject of the email.
         */
        subject: string;

        /**
         * An HTML template for the email body. Either `html_body` or `visual_blocks` must
         * be provided.
         */
        html_body?: string;

        /**
         * The settings for the email template. Can be omitted.
         */
        settings?: EmailTemplate.Settings | null;

        /**
         * A text template for the email body. Only present if opted out from
         * autogenerating it from the HTML template.
         */
        text_body?: string | null;

        /**
         * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
         * provided.
         */
        visual_blocks?: Array<
          | EmailTemplate.ButtonSetBlock
          | EmailTemplate.DividerBlock
          | EmailTemplate.HTMLBlock
          | EmailTemplate.MarkdownBlock
          | EmailTemplate.PartialBlock
        >;
      }

      export namespace EmailTemplate {
        /**
         * The settings for the email template. Can be omitted.
         */
        export interface Settings {
          /**
           * The object path in the data payload (of the workflow trigger call) to resolve
           * attachments.
           */
          attachment_key?: string | null;

          /**
           * The key of the email layout which the step is using.
           */
          layout_key?: string | null;

          /**
           * A liquid template that will be injected into the layout above the message
           * template content.
           */
          pre_content?: string | null;
        }

        /**
         * A button set block in an email template.
         */
        export interface ButtonSetBlock {
          /**
           * The ID of the block.
           */
          id: string;

          buttons: Array<ButtonSetBlock.Button>;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: ButtonSetBlock.LayoutAttrs;
        }

        export namespace ButtonSetBlock {
          /**
           * A button in a button set block.
           */
          export interface Button {
            action: string;

            label: string;

            variant: string;

            size_attrs?: Button.SizeAttrs;

            style_attrs?: Button.StyleAttrs;
          }

          export namespace Button {
            export interface SizeAttrs {
              is_fullwidth?: boolean;

              size?: 'sm' | 'md' | 'lg';
            }

            export interface StyleAttrs {
              background_color?: string;

              border_color?: string;

              border_radius?: number;

              border_width?: number;

              text_color?: string;
            }
          }

          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            column_gap: number;

            horizontal_align: 'left' | 'center' | 'right';

            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A divider block in an email template.
         */
        export interface DividerBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: DividerBlock.LayoutAttrs;
        }

        export namespace DividerBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * An HTML block in an email template.
         */
        export interface HTMLBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The HTML content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;
        }

        /**
         * A markdown block in an email template.
         */
        export interface MarkdownBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The markdown content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The flavor of markdown to use for the block.
           */
          variant: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: MarkdownBlock.LayoutAttrs;
        }

        export namespace MarkdownBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A partial block in an email template, used to render a reusable partial
         * component.
         */
        export interface PartialBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The attributes to pass to the partial block.
           */
          attrs: Record<string, unknown>;

          /**
           * The key of the partial block to invoke.
           */
          key: string;

          /**
           * The name of the partial block.
           */
          name: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: PartialBlock.LayoutAttrs;
        }

        export namespace PartialBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }
      }

      /**
       * An in-app feed template.
       */
      export interface InAppFeedTemplate {
        /**
         * The markdown body of the in-app feed.
         */
        markdown_body: string;

        /**
         * The action buttons of the in-app feed.
         */
        action_buttons?: Array<InAppFeedTemplate.ActionButton>;

        /**
         * The URL to navigate to when the in-app feed is tapped. Can be omitted for
         * multi-action templates, where the action buttons will be used instead.
         */
        action_url?: string | null;
      }

      export namespace InAppFeedTemplate {
        /**
         * A single-action button to be rendered in an in-app feed cell.
         */
        export interface ActionButton {
          /**
           * The action of the action button.
           */
          action: string;

          /**
           * The label of the action button.
           */
          label: string;
        }
      }

      /**
       * An SMS template.
       */
      export interface SMSTemplate {
        /**
         * The message of the SMS.
         */
        text_body: string;

        /**
         * The settings for the SMS template.
         */
        settings?: SMSTemplate.Settings | null;
      }

      export namespace SMSTemplate {
        /**
         * The settings for the SMS template.
         */
        export interface Settings {
          /**
           * A JSON object overrides the payload sent to the SMS provider.
           */
          payload_overrides?: string | null;

          /**
           * An override for the phone number to send the SMS to. When not set, defaults to
           * `recipient.phone_number`.
           */
          to_number?: string | null;
        }
      }

      /**
       * A push notification template.
       */
      export interface PushTemplate {
        /**
         * The body of the push notification.
         */
        text_body: string;

        /**
         * The title of the push notification.
         */
        title: string;

        /**
         * The settings for the push template. Can be omitted.
         */
        settings?: PushTemplate.Settings | null;
      }

      export namespace PushTemplate {
        /**
         * The settings for the push template. Can be omitted.
         */
        export interface Settings {
          /**
           * The delivery type of the push notification. Defaults to `content`. Set as silent
           * to send a data-only notification. When set to `data`, no body will be sent.
           */
          delivery_type?: 'silent' | 'content';

          /**
           * A JSON object overrides the payload sent to the push provider.
           */
          payload_overrides?: string;
        }
      }

      /**
       * A chat template.
       */
      export interface ChatTemplate {
        /**
         * The markdown body of the chat template.
         */
        markdown_body: string;

        /**
         * A JSON template for the chat notification message payload. Only present if not
         * using the markdown body.
         */
        json_body?: string | null;

        /**
         * The summary of the chat template.
         */
        summary?: string;
      }

      /**
       * A webhook template. By default, a webhook step will use the request settings you
       * configured in your webhook channel. You can override this as you see fit on a
       * per-step basis.
       */
      export interface WebhookTemplate {
        /**
         * The HTTP method of the webhook.
         */
        method: 'get' | 'post' | 'put' | 'delete' | 'patch';

        /**
         * The URL of the webhook.
         */
        url: string;

        /**
         * A body of the request. Only used for POST or PUT requests.
         */
        body?: string | null;

        /**
         * A list of key-value pairs for the request headers. Each object should contain
         * key and value fields with string values.
         */
        headers?: Array<WebhookTemplate.Header>;

        /**
         * A list of key-value pairs for the request query params. Each object should
         * contain key and value fields with string values.
         */
        query_params?: Array<WebhookTemplate.QueryParam>;
      }

      export namespace WebhookTemplate {
        export interface Header {
          /**
           * The key of the header.
           */
          key: string;

          /**
           * The value of the header.
           */
          value: string;
        }

        export interface QueryParam {
          /**
           * The key of the query param.
           */
          key: string;

          /**
           * The value of the query param.
           */
          value: string;
        }
      }

      /**
       * Email channel settings
       */
      export interface EmailChannelSettings {
        /**
         * The BCC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        bcc_address?: string | null;

        /**
         * The CC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        cc_address?: string | null;

        /**
         * The email address from which this channel will send. Supports liquid.
         */
        from_email?: string | null;

        /**
         * The name from which this channel will send. Supports liquid
         */
        from_name?: string | null;

        /**
         * A JSON template for any custom overrides to merge into the API payload that is
         * sent to the email provider. Supports liquid.
         */
        json_overrides?: string | null;

        /**
         * Whether to track link clicks on email notifications.
         */
        link_tracking?: boolean;

        /**
         * Whether to track opens on email notifications.
         */
        open_tracking?: boolean;

        /**
         * The Reply-to address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        reply_to_address?: string | null;

        /**
         * The email address to which this channel will send. Defaults to
         * `recipient.email`. Supports liquid.
         */
        to_address?: string;
      }

      /**
       * In-app feed channel settings
       */
      export interface InAppFeedChannelSettings {
        /**
         * Whether to track link clicks on in-app feed notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * SMS channel settings
       */
      export interface SMSChannelSettings {
        /**
         * Whether to track link clicks on SMS notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * Chat channel settings
       */
      export interface ChatChannelSettings {
        /**
         * Whether to resolve chat provider user IDs using a Knock user's email address.
         * Only relevant for Slack channels for the time being.
         */
        email_based_user_id_resolution?: boolean;

        /**
         * Whether to track link clicks on chat notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * A send window time for a notification. Describes a single day.
       */
      export interface SendWindow {
        day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

        type: 'send' | 'do_not_send';

        from?: string | null;

        until?: string | null;
      }
    }

    /**
     * A delay step within a workflow.
     */
    export interface WorkflowDelayStep {
      /**
       * A group of conditions to be evaluated
       */
      conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      settings: WorkflowDelayStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'delay';
    }

    export namespace WorkflowDelayStep {
      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      export interface Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        delay_for?: Settings.DelayFor | null;

        /**
         * When set will use the path to resolve the delay into a timestamp from the
         * property referenced
         */
        delay_until_field_path?: string;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface DelayFor {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow batch step
     */
    export interface WorkflowBatchStep {
      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the batch step.
       */
      settings: WorkflowBatchStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'batch';
    }

    export namespace WorkflowBatchStep {
      /**
       * The settings for the batch step.
       */
      export interface Settings {
        /**
         * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
         * When set to “flush_leading”, the first item in the batch will be executed
         * immediately, and the rest will be batched.
         */
        batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

        /**
         * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
         */
        batch_items_max_limit?: number | null;

        /**
         * The maximum number of batch items allowed to be rendered into a template.
         * Between: 1 and 100. Defaults to 10.
         */
        batch_items_render_limit?: number | null;

        /**
         * The data property to use to batch notifications per recipient.
         */
        batch_key?: string | null;

        /**
         * The order describing whether to return the first or last ten batch items in the
         * activities variable. One of: “asc” or “desc”.
         */
        batch_order?: 'asc' | 'desc' | null;

        /**
         * The data path to resolve the batch window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        batch_until_field_path?: string | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window?: Settings.BatchWindow | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

        /**
         * The type of the batch window used. One of: “fixed” or “sliding”.
         */
        batch_window_type?: 'fixed' | 'sliding' | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }

        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindowExtensionLimit {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow throttle step
     */
    export interface WorkflowThrottleStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the throttle step.
       */
      settings: WorkflowThrottleStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'throttle';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowThrottleStep.ConditionGroupAllMatch
        | WorkflowThrottleStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;
    }

    export namespace WorkflowThrottleStep {
      /**
       * The settings for the throttle step.
       */
      export interface Settings {
        /**
         * The data property to use to throttle notifications per recipient.
         */
        throttle_key?: string | null;

        /**
         * The maximum number of workflows to allow within the duration window. Defaults
         * to 1.
         */
        throttle_limit?: number | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        throttle_window?: Settings.ThrottleWindow | null;

        /**
         * The data path to resolve the throttle window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        throttle_window_field_path?: string | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface ThrottleWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A workflow trigger workflow step.
     */
    export interface WorkflowTriggerWorkflowStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the workflow trigger workflow step.
       */
      settings: WorkflowTriggerWorkflowStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'trigger_workflow';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
        | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
        | null;

      /**
       * A description for the workflow step.
       */
      description?: string;
    }

    export namespace WorkflowTriggerWorkflowStep {
      /**
       * The settings for the workflow trigger workflow step.
       */
      export interface Settings {
        /**
         * The actor to trigger the workflow with. Supports liquid.
         */
        actor?: string;

        /**
         * The cancellation key to trigger the workflow with. Supports liquid.
         */
        cancellation_key?: string;

        /**
         * The data to be supplied to the workflow. Supports liquid.
         */
        data?: string;

        recipients?: unknown;

        /**
         * The tenant to trigger the workflow with. Supports liquid.
         */
        tenant?: string;

        /**
         * The key of the workflow to trigger. Supports liquid.
         */
        workflow_key?: string;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A map of workflow settings.
     */
    export interface Settings {
      /**
       * Whether the workflow is commercial. Defaults to false.
       */
      is_commercial?: boolean;

      /**
       * Whether to ignore recipient preferences for a given type of notification. If
       * true, will send for every channel in the workflow even if the recipient has
       * opted out of a certain kind. Defaults to false.
       */
      override_preferences?: boolean;
    }
  }
}

export interface WorkflowValidateParams {
  /**
   * Query param: A slug of the environment in which to validate the workflow.
   */
  environment: string;

  /**
   * Body param: A workflow request for upserting a workflow.
   */
  workflow: WorkflowValidateParams.Workflow;
}

export namespace WorkflowValidateParams {
  /**
   * A workflow request for upserting a workflow.
   */
  export interface Workflow {
    /**
     * A name for the workflow. Must be at maximum 255 characters in length.
     */
    name: string;

    /**
     * A list of workflow step objects in the workflow, which may contain any of:
     * channel step, delay step, batch step, fetch step.
     */
    steps: Array<
      | Workflow.WorkflowChannelStep
      | Workflow.WorkflowDelayStep
      | Workflow.WorkflowBatchStep
      | Workflow.WorkflowThrottleStep
      | unknown
      | Workflow.WorkflowTriggerWorkflowStep
    >;

    /**
     * A list of categories that the workflow belongs to.
     */
    categories?: Array<string>;

    /**
     * A group of conditions to be evaluated
     */
    conditions?: Workflow.ConditionGroupAllMatch | Workflow.ConditionGroupAnyMatch | null;

    /**
     * An arbitrary string attached to a workflow object. Useful for adding notes about
     * the workflow for internal purposes. Maximum of 280 characters allowed.
     */
    description?: string;

    /**
     * A map of workflow settings.
     */
    settings?: Workflow.Settings;

    /**
     * A JSON schema for the expected structure of the workflow trigger's data payload.
     * Used to validate trigger requests. (optional)
     */
    trigger_data_json_schema?: unknown;

    /**
     * The frequency at which the workflow should be triggered. One of:
     * "once_per_recipient", "once_per_recipient_per_tenant", "every_trigger". Defaults
     * to "every_trigger".
     */
    trigger_frequency?: 'every_trigger' | 'once_per_recipient' | 'once_per_recipient_per_tenant';
  }

  export namespace Workflow {
    /**
     * A channel step within a workflow.
     */
    export interface WorkflowChannelStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The message template set up with the channel step. The shape of the template
       * depends on the type of the channel you'll be sending to. See below for
       * definitions of each channel type template: email, in-app, SMS, push, chat, and
       * webhook.
       */
      template:
        | WorkflowChannelStep.EmailTemplate
        | WorkflowChannelStep.InAppFeedTemplate
        | WorkflowChannelStep.SMSTemplate
        | WorkflowChannelStep.PushTemplate
        | WorkflowChannelStep.ChatTemplate
        | WorkflowChannelStep.WebhookTemplate;

      /**
       * The type of the workflow step.
       */
      type: 'channel';

      /**
       * The key of the channel group to which the channel step will be sending a
       * notification. A channel step can have either a channel key or a channel group
       * key, but not both.
       */
      channel_group_key?: string | null;

      /**
       * The key of the channel to which the channel step will be sending a notification.
       * A channel step can have either a channel key or a channel group key, but not
       * both.
       */
      channel_key?: string | null;

      /**
       * A map of channel overrides for the channel step.
       */
      channel_overrides?:
        | WorkflowChannelStep.EmailChannelSettings
        | WorkflowChannelStep.InAppFeedChannelSettings
        | WorkflowChannelStep.SMSChannelSettings
        | WorkflowChannelStep.ChatChannelSettings
        | null;

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowChannelStep.ConditionGroupAllMatch
        | WorkflowChannelStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;

      /**
       * A list of send window objects. Must include one send window object per day of
       * the week.
       */
      send_windows?: Array<WorkflowChannelStep.SendWindow> | null;
    }

    export namespace WorkflowChannelStep {
      /**
       * An email message template.
       */
      export interface EmailTemplate {
        /**
         * The subject of the email.
         */
        subject: string;

        /**
         * An HTML template for the email body. Either `html_body` or `visual_blocks` must
         * be provided.
         */
        html_body?: string;

        /**
         * The settings for the email template. Can be omitted.
         */
        settings?: EmailTemplate.Settings | null;

        /**
         * A text template for the email body. Only present if opted out from
         * autogenerating it from the HTML template.
         */
        text_body?: string | null;

        /**
         * The visual blocks of the email. Either `html_body` or `visual_blocks` must be
         * provided.
         */
        visual_blocks?: Array<
          | EmailTemplate.ButtonSetBlock
          | EmailTemplate.DividerBlock
          | EmailTemplate.HTMLBlock
          | EmailTemplate.MarkdownBlock
          | EmailTemplate.PartialBlock
        >;
      }

      export namespace EmailTemplate {
        /**
         * The settings for the email template. Can be omitted.
         */
        export interface Settings {
          /**
           * The object path in the data payload (of the workflow trigger call) to resolve
           * attachments.
           */
          attachment_key?: string | null;

          /**
           * The key of the email layout which the step is using.
           */
          layout_key?: string | null;

          /**
           * A liquid template that will be injected into the layout above the message
           * template content.
           */
          pre_content?: string | null;
        }

        /**
         * A button set block in an email template.
         */
        export interface ButtonSetBlock {
          /**
           * The ID of the block.
           */
          id: string;

          buttons: Array<ButtonSetBlock.Button>;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: ButtonSetBlock.LayoutAttrs;
        }

        export namespace ButtonSetBlock {
          /**
           * A button in a button set block.
           */
          export interface Button {
            action: string;

            label: string;

            variant: string;

            size_attrs?: Button.SizeAttrs;

            style_attrs?: Button.StyleAttrs;
          }

          export namespace Button {
            export interface SizeAttrs {
              is_fullwidth?: boolean;

              size?: 'sm' | 'md' | 'lg';
            }

            export interface StyleAttrs {
              background_color?: string;

              border_color?: string;

              border_radius?: number;

              border_width?: number;

              text_color?: string;
            }
          }

          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            column_gap: number;

            horizontal_align: 'left' | 'center' | 'right';

            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A divider block in an email template.
         */
        export interface DividerBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: DividerBlock.LayoutAttrs;
        }

        export namespace DividerBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * An HTML block in an email template.
         */
        export interface HTMLBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The HTML content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;
        }

        /**
         * A markdown block in an email template.
         */
        export interface MarkdownBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The markdown content of the block.
           */
          content: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The flavor of markdown to use for the block.
           */
          variant: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: MarkdownBlock.LayoutAttrs;
        }

        export namespace MarkdownBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }

        /**
         * A partial block in an email template, used to render a reusable partial
         * component.
         */
        export interface PartialBlock {
          /**
           * The ID of the block.
           */
          id: string;

          /**
           * The attributes to pass to the partial block.
           */
          attrs: Record<string, unknown>;

          /**
           * The key of the partial block to invoke.
           */
          key: string;

          /**
           * The name of the partial block.
           */
          name: string;

          /**
           * The type of the block.
           */
          type: string;

          /**
           * The version of the block.
           */
          version: number;

          /**
           * The layout attributes of the block.
           */
          layout_attrs?: PartialBlock.LayoutAttrs;
        }

        export namespace PartialBlock {
          /**
           * The layout attributes of the block.
           */
          export interface LayoutAttrs {
            padding_bottom: number;

            padding_left: number;

            padding_right: number;

            padding_top: number;
          }
        }
      }

      /**
       * An in-app feed template.
       */
      export interface InAppFeedTemplate {
        /**
         * The markdown body of the in-app feed.
         */
        markdown_body: string;

        /**
         * The action buttons of the in-app feed.
         */
        action_buttons?: Array<InAppFeedTemplate.ActionButton>;

        /**
         * The URL to navigate to when the in-app feed is tapped. Can be omitted for
         * multi-action templates, where the action buttons will be used instead.
         */
        action_url?: string | null;
      }

      export namespace InAppFeedTemplate {
        /**
         * A single-action button to be rendered in an in-app feed cell.
         */
        export interface ActionButton {
          /**
           * The action of the action button.
           */
          action: string;

          /**
           * The label of the action button.
           */
          label: string;
        }
      }

      /**
       * An SMS template.
       */
      export interface SMSTemplate {
        /**
         * The message of the SMS.
         */
        text_body: string;

        /**
         * The settings for the SMS template.
         */
        settings?: SMSTemplate.Settings | null;
      }

      export namespace SMSTemplate {
        /**
         * The settings for the SMS template.
         */
        export interface Settings {
          /**
           * A JSON object overrides the payload sent to the SMS provider.
           */
          payload_overrides?: string | null;

          /**
           * An override for the phone number to send the SMS to. When not set, defaults to
           * `recipient.phone_number`.
           */
          to_number?: string | null;
        }
      }

      /**
       * A push notification template.
       */
      export interface PushTemplate {
        /**
         * The body of the push notification.
         */
        text_body: string;

        /**
         * The title of the push notification.
         */
        title: string;

        /**
         * The settings for the push template. Can be omitted.
         */
        settings?: PushTemplate.Settings | null;
      }

      export namespace PushTemplate {
        /**
         * The settings for the push template. Can be omitted.
         */
        export interface Settings {
          /**
           * The delivery type of the push notification. Defaults to `content`. Set as silent
           * to send a data-only notification. When set to `data`, no body will be sent.
           */
          delivery_type?: 'silent' | 'content';

          /**
           * A JSON object overrides the payload sent to the push provider.
           */
          payload_overrides?: string;
        }
      }

      /**
       * A chat template.
       */
      export interface ChatTemplate {
        /**
         * The markdown body of the chat template.
         */
        markdown_body: string;

        /**
         * A JSON template for the chat notification message payload. Only present if not
         * using the markdown body.
         */
        json_body?: string | null;

        /**
         * The summary of the chat template.
         */
        summary?: string;
      }

      /**
       * A webhook template. By default, a webhook step will use the request settings you
       * configured in your webhook channel. You can override this as you see fit on a
       * per-step basis.
       */
      export interface WebhookTemplate {
        /**
         * The HTTP method of the webhook.
         */
        method: 'get' | 'post' | 'put' | 'delete' | 'patch';

        /**
         * The URL of the webhook.
         */
        url: string;

        /**
         * A body of the request. Only used for POST or PUT requests.
         */
        body?: string | null;

        /**
         * A list of key-value pairs for the request headers. Each object should contain
         * key and value fields with string values.
         */
        headers?: Array<WebhookTemplate.Header>;

        /**
         * A list of key-value pairs for the request query params. Each object should
         * contain key and value fields with string values.
         */
        query_params?: Array<WebhookTemplate.QueryParam>;
      }

      export namespace WebhookTemplate {
        export interface Header {
          /**
           * The key of the header.
           */
          key: string;

          /**
           * The value of the header.
           */
          value: string;
        }

        export interface QueryParam {
          /**
           * The key of the query param.
           */
          key: string;

          /**
           * The value of the query param.
           */
          value: string;
        }
      }

      /**
       * Email channel settings
       */
      export interface EmailChannelSettings {
        /**
         * The BCC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        bcc_address?: string | null;

        /**
         * The CC address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        cc_address?: string | null;

        /**
         * The email address from which this channel will send. Supports liquid.
         */
        from_email?: string | null;

        /**
         * The name from which this channel will send. Supports liquid
         */
        from_name?: string | null;

        /**
         * A JSON template for any custom overrides to merge into the API payload that is
         * sent to the email provider. Supports liquid.
         */
        json_overrides?: string | null;

        /**
         * Whether to track link clicks on email notifications.
         */
        link_tracking?: boolean;

        /**
         * Whether to track opens on email notifications.
         */
        open_tracking?: boolean;

        /**
         * The Reply-to address on email notifications. Supports liquid. Defaults to
         * `from_address`.
         */
        reply_to_address?: string | null;

        /**
         * The email address to which this channel will send. Defaults to
         * `recipient.email`. Supports liquid.
         */
        to_address?: string;
      }

      /**
       * In-app feed channel settings
       */
      export interface InAppFeedChannelSettings {
        /**
         * Whether to track link clicks on in-app feed notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * SMS channel settings
       */
      export interface SMSChannelSettings {
        /**
         * Whether to track link clicks on SMS notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * Chat channel settings
       */
      export interface ChatChannelSettings {
        /**
         * Whether to resolve chat provider user IDs using a Knock user's email address.
         * Only relevant for Slack channels for the time being.
         */
        email_based_user_id_resolution?: boolean;

        /**
         * Whether to track link clicks on chat notifications.
         */
        link_tracking?: boolean;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * A send window time for a notification. Describes a single day.
       */
      export interface SendWindow {
        day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

        type: 'send' | 'do_not_send';

        from?: string | null;

        until?: string | null;
      }
    }

    /**
     * A delay step within a workflow.
     */
    export interface WorkflowDelayStep {
      /**
       * A group of conditions to be evaluated
       */
      conditions: WorkflowDelayStep.ConditionGroupAllMatch | WorkflowDelayStep.ConditionGroupAnyMatch | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      settings: WorkflowDelayStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'delay';
    }

    export namespace WorkflowDelayStep {
      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }

      /**
       * The settings for the delay step. Both fields can be set to compute a delay where
       * `delay_for` is an offset from the `delay_until_field_path`.
       */
      export interface Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        delay_for?: Settings.DelayFor | null;

        /**
         * When set will use the path to resolve the delay into a timestamp from the
         * property referenced
         */
        delay_until_field_path?: string;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface DelayFor {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow batch step
     */
    export interface WorkflowBatchStep {
      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description: string | null;

      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the batch step.
       */
      settings: WorkflowBatchStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'batch';
    }

    export namespace WorkflowBatchStep {
      /**
       * The settings for the batch step.
       */
      export interface Settings {
        /**
         * The execution mode of the batch step. One of: “accumulate” or “flush_leading”.
         * When set to “flush_leading”, the first item in the batch will be executed
         * immediately, and the rest will be batched.
         */
        batch_execution_mode?: 'accumulate' | 'flush_leading' | null;

        /**
         * The maximum number of batch items allowed in a batch. Between: 2 and 1000.
         */
        batch_items_max_limit?: number | null;

        /**
         * The maximum number of batch items allowed to be rendered into a template.
         * Between: 1 and 100. Defaults to 10.
         */
        batch_items_render_limit?: number | null;

        /**
         * The data property to use to batch notifications per recipient.
         */
        batch_key?: string | null;

        /**
         * The order describing whether to return the first or last ten batch items in the
         * activities variable. One of: “asc” or “desc”.
         */
        batch_order?: 'asc' | 'desc' | null;

        /**
         * The data path to resolve the batch window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        batch_until_field_path?: string | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window?: Settings.BatchWindow | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        batch_window_extension_limit?: Settings.BatchWindowExtensionLimit | null;

        /**
         * The type of the batch window used. One of: “fixed” or “sliding”.
         */
        batch_window_type?: 'fixed' | 'sliding' | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }

        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface BatchWindowExtensionLimit {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }
    }

    /**
     * A workflow throttle step
     */
    export interface WorkflowThrottleStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the throttle step.
       */
      settings: WorkflowThrottleStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'throttle';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowThrottleStep.ConditionGroupAllMatch
        | WorkflowThrottleStep.ConditionGroupAnyMatch
        | null;

      /**
       * An arbitrary string attached to a workflow step. Useful for adding notes about
       * the workflow for internal purposes.
       */
      description?: string | null;
    }

    export namespace WorkflowThrottleStep {
      /**
       * The settings for the throttle step.
       */
      export interface Settings {
        /**
         * The data property to use to throttle notifications per recipient.
         */
        throttle_key?: string | null;

        /**
         * The maximum number of workflows to allow within the duration window. Defaults
         * to 1.
         */
        throttle_limit?: number | null;

        /**
         * A duration of time, represented as a unit and a value.
         */
        throttle_window?: Settings.ThrottleWindow | null;

        /**
         * The data path to resolve the throttle window. The resolved value must be an
         * ISO-8601 timestamp.
         */
        throttle_window_field_path?: string | null;
      }

      export namespace Settings {
        /**
         * A duration of time, represented as a unit and a value.
         */
        export interface ThrottleWindow {
          unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months';

          value: number;
        }
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A workflow trigger workflow step.
     */
    export interface WorkflowTriggerWorkflowStep {
      /**
       * A name for the workflow step.
       */
      name: string;

      /**
       * The reference key of the workflow step. Must be unique per workflow.
       */
      ref: string;

      /**
       * The settings for the workflow trigger workflow step.
       */
      settings: WorkflowTriggerWorkflowStep.Settings;

      /**
       * The type of the workflow step.
       */
      type: 'trigger_workflow';

      /**
       * A group of conditions to be evaluated
       */
      conditions?:
        | WorkflowTriggerWorkflowStep.ConditionGroupAllMatch
        | WorkflowTriggerWorkflowStep.ConditionGroupAnyMatch
        | null;

      /**
       * A description for the workflow step.
       */
      description?: string;
    }

    export namespace WorkflowTriggerWorkflowStep {
      /**
       * The settings for the workflow trigger workflow step.
       */
      export interface Settings {
        /**
         * The actor to trigger the workflow with. Supports liquid.
         */
        actor?: string;

        /**
         * The cancellation key to trigger the workflow with. Supports liquid.
         */
        cancellation_key?: string;

        /**
         * The data to be supplied to the workflow. Supports liquid.
         */
        data?: string;

        recipients?: unknown;

        /**
         * The tenant to trigger the workflow with. Supports liquid.
         */
        tenant?: string;

        /**
         * The key of the workflow to trigger. Supports liquid.
         */
        workflow_key?: string;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }

      /**
       * A group of conditions that any must be met. Can contain nested alls.
       */
      export interface ConditionGroupAnyMatch {
        any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
      }

      export namespace ConditionGroupAnyMatch {
        /**
         * A condition to be evaluated
         */
        export interface Condition {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }

        /**
         * A group of conditions that must all be met.
         */
        export interface ConditionGroupAllMatch {
          all: Array<ConditionGroupAllMatch.All>;
        }

        export namespace ConditionGroupAllMatch {
          /**
           * A condition to be evaluated
           */
          export interface All {
            /**
             * The operator to use in the evaluation of the condition.
             */
            operator:
              | 'equal_to'
              | 'not_equal_to'
              | 'greater_than'
              | 'less_than'
              | 'greater_than_or_equal_to'
              | 'less_than_or_equal_to'
              | 'contains'
              | 'not_contains'
              | 'contains_all'
              | 'empty'
              | 'not_empty'
              | 'is_audience_member'
              | 'is_not_audience_member';

            /**
             * The variable to be evaluated. Variables can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            variable: string;

            /**
             * The argument to be evaluated. Arguments can be either static values or dynamic
             * properties. Static values will always be JSON decoded so will support strings,
             * lists, objects, numbers, and booleans. Dynamic values should be path
             * expressions.
             */
            argument?: string | null;
          }
        }
      }
    }

    /**
     * A group of conditions that must all be met.
     */
    export interface ConditionGroupAllMatch {
      all: Array<ConditionGroupAllMatch.All>;
    }

    export namespace ConditionGroupAllMatch {
      /**
       * A condition to be evaluated
       */
      export interface All {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }
    }

    /**
     * A group of conditions that any must be met. Can contain nested alls.
     */
    export interface ConditionGroupAnyMatch {
      any: Array<ConditionGroupAnyMatch.Condition | ConditionGroupAnyMatch.ConditionGroupAllMatch>;
    }

    export namespace ConditionGroupAnyMatch {
      /**
       * A condition to be evaluated
       */
      export interface Condition {
        /**
         * The operator to use in the evaluation of the condition.
         */
        operator:
          | 'equal_to'
          | 'not_equal_to'
          | 'greater_than'
          | 'less_than'
          | 'greater_than_or_equal_to'
          | 'less_than_or_equal_to'
          | 'contains'
          | 'not_contains'
          | 'contains_all'
          | 'empty'
          | 'not_empty'
          | 'is_audience_member'
          | 'is_not_audience_member';

        /**
         * The variable to be evaluated. Variables can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        variable: string;

        /**
         * The argument to be evaluated. Arguments can be either static values or dynamic
         * properties. Static values will always be JSON decoded so will support strings,
         * lists, objects, numbers, and booleans. Dynamic values should be path
         * expressions.
         */
        argument?: string | null;
      }

      /**
       * A group of conditions that must all be met.
       */
      export interface ConditionGroupAllMatch {
        all: Array<ConditionGroupAllMatch.All>;
      }

      export namespace ConditionGroupAllMatch {
        /**
         * A condition to be evaluated
         */
        export interface All {
          /**
           * The operator to use in the evaluation of the condition.
           */
          operator:
            | 'equal_to'
            | 'not_equal_to'
            | 'greater_than'
            | 'less_than'
            | 'greater_than_or_equal_to'
            | 'less_than_or_equal_to'
            | 'contains'
            | 'not_contains'
            | 'contains_all'
            | 'empty'
            | 'not_empty'
            | 'is_audience_member'
            | 'is_not_audience_member';

          /**
           * The variable to be evaluated. Variables can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          variable: string;

          /**
           * The argument to be evaluated. Arguments can be either static values or dynamic
           * properties. Static values will always be JSON decoded so will support strings,
           * lists, objects, numbers, and booleans. Dynamic values should be path
           * expressions.
           */
          argument?: string | null;
        }
      }
    }

    /**
     * A map of workflow settings.
     */
    export interface Settings {
      /**
       * Whether the workflow is commercial. Defaults to false.
       */
      is_commercial?: boolean;

      /**
       * Whether to ignore recipient preferences for a given type of notification. If
       * true, will send for every channel in the workflow even if the recipient has
       * opted out of a certain kind. Defaults to false.
       */
      override_preferences?: boolean;
    }
  }
}

Workflows.Steps = Steps;

export declare namespace Workflows {
  export {
    type WorkflowRetrieveResponse as WorkflowRetrieveResponse,
    type WorkflowListResponse as WorkflowListResponse,
    type WorkflowActivateResponse as WorkflowActivateResponse,
    type WorkflowRunResponse as WorkflowRunResponse,
    type WorkflowUpsertResponse as WorkflowUpsertResponse,
    type WorkflowValidateResponse as WorkflowValidateResponse,
    type WorkflowRetrieveParams as WorkflowRetrieveParams,
    type WorkflowListParams as WorkflowListParams,
    type WorkflowActivateParams as WorkflowActivateParams,
    type WorkflowRunParams as WorkflowRunParams,
    type WorkflowUpsertParams as WorkflowUpsertParams,
    type WorkflowValidateParams as WorkflowValidateParams,
  };

  export {
    Steps as Steps,
    type StepPreviewTemplateResponse as StepPreviewTemplateResponse,
    type StepPreviewTemplateParams as StepPreviewTemplateParams,
  };
}
